/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"lk": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./lk.js","vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/sticky-sidebar/src/sticky-sidebar.js":
/*!*************************************************************************!*\
  !*** F:/html/ewallet/node_modules/sticky-sidebar/src/sticky-sidebar.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Sticky Sidebar JavaScript Plugin.\r\n * @version 3.3.1\r\n * @author Ahmed Bouhuolia <a.bouhuolia@gmail.com>\r\n * @license The MIT License (MIT)\r\n */\r\nconst StickySidebar = (() => {\r\n  \r\n    // ---------------------------------\r\n    // # Define Constants\r\n    // ---------------------------------\r\n    //\r\n    const EVENT_KEY = '.stickySidebar';\r\n    const VERSION   = '3.3.1';\r\n  \r\n    const DEFAULTS = {\r\n      \r\n      /**\r\n       * Additional top spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      topSpacing: 0,\r\n  \r\n      /**\r\n       * Additional bottom spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      bottomSpacing: 0,\r\n  \r\n      /**\r\n       * Container sidebar selector to know what the beginning and end of sticky element.\r\n       * @type {String|False}\r\n       */\r\n      containerSelector: false,\r\n  \r\n      /**\r\n       * Inner wrapper selector.\r\n       * @type {String}\r\n       */\r\n      innerWrapperSelector: '.inner-wrapper-sticky',\r\n  \r\n      /**\r\n       * The name of CSS class to apply to elements when they have become stuck.\r\n       * @type {String|False}\r\n       */\r\n      stickyClass: 'is-affixed',\r\n  \r\n      /**\r\n       * Detect when sidebar and its container change height so re-calculate their dimensions.\r\n       * @type {Boolean}\r\n       */\r\n      resizeSensor: true,\r\n  \r\n      /**\r\n       * The sidebar returns to its normal position if its width below this value.\r\n       * @type {Numeric}\r\n       */\r\n      minWidth: false\r\n    };\r\n  \r\n    // ---------------------------------\r\n    // # Class Definition\r\n    // ---------------------------------\r\n    //\r\n    /**\r\n     * Sticky Sidebar Class.\r\n     * @public\r\n     */\r\n    class StickySidebar{\r\n  \r\n      /**\r\n       * Sticky Sidebar Constructor.\r\n       * @constructor\r\n       * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\r\n       * @param {Object} options - The options of sticky sidebar.\r\n       */\r\n      constructor(sidebar, options = {}){\r\n        this.options = StickySidebar.extend(DEFAULTS, options);\r\n  \r\n        // Sidebar element query if there's no one, throw error.\r\n        this.sidebar = ('string' === typeof sidebar ) ? document.querySelector(sidebar) : sidebar;\r\n        if( 'undefined' === typeof this.sidebar )\r\n          throw new Error(\"There is no specific sidebar element.\");\r\n  \r\n        this.sidebarInner = false;\r\n        this.container = this.sidebar.parentElement;\r\n  \r\n        // Current Affix Type of sidebar element.\r\n        this.affixedType = 'STATIC';\r\n        this.direction = 'down';\r\n        this.support = {\r\n          transform:   false,\r\n          transform3d: false\r\n        };\r\n  \r\n        this._initialized = false;\r\n        this._reStyle = false;\r\n        this._breakpoint = false;\r\n        this._resizeListeners = [];\r\n        \r\n        // Dimensions of sidebar, container and screen viewport.\r\n        this.dimensions = {\r\n          translateY: 0,\r\n          topSpacing: 0,\r\n          lastTopSpacing: 0,\r\n          bottomSpacing: 0,\r\n          lastBottomSpacing: 0,\r\n          sidebarHeight: 0,\r\n          sidebarWidth: 0,\r\n          containerTop: 0,\r\n          containerHeight: 0,\r\n          viewportHeight: 0,\r\n          viewportTop: 0, \r\n          lastViewportTop: 0,\r\n        };\r\n  \r\n        // Bind event handlers for referencability.\r\n        ['handleEvent'].forEach( (method) => {\r\n          this[method] = this[method].bind(this);\r\n        });\r\n  \r\n        // Initialize sticky sidebar for first time.\r\n        this.initialize();\r\n      }\r\n  \r\n      /**\r\n       * Initializes the sticky sidebar by adding inner wrapper, define its container, \r\n       * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\r\n       * @private\r\n       */\r\n      initialize(){\r\n        this._setSupportFeatures();\r\n  \r\n        // Get sticky sidebar inner wrapper, if not found, will create one.\r\n        if( this.options.innerWrapperSelector ){\r\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\r\n  \r\n          if( null === this.sidebarInner )\r\n            this.sidebarInner = false;\r\n        }\r\n        \r\n        if( ! this.sidebarInner ){\r\n          let wrapper = document.createElement('div');\r\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\r\n          this.sidebar.appendChild(wrapper);\r\n  \r\n          while( this.sidebar.firstChild != wrapper )\r\n            wrapper.appendChild(this.sidebar.firstChild);\r\n  \r\n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\r\n        }\r\n  \r\n        // Container wrapper of the sidebar.\r\n        if( this.options.containerSelector ){\r\n          let containers = document.querySelectorAll(this.options.containerSelector);\r\n          containers = Array.prototype.slice.call(containers);\r\n  \r\n          containers.forEach((container, item) => {\r\n            if( ! container.contains(this.sidebar) ) return;\r\n            this.container = container;\r\n          });\r\n  \r\n          if( ! containers.length )\r\n            throw new Error(\"The container does not contains on the sidebar.\");\r\n        }\r\n        \r\n        // If top/bottom spacing is not function parse value to integer.\r\n        if( 'function' !== typeof this.options.topSpacing )\r\n          this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\r\n  \r\n        if( 'function' !== typeof this.options.bottomSpacing )\r\n          this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0;\r\n            \r\n        // Breakdown sticky sidebar if screen width below `options.minWidth`.\r\n        this._widthBreakpoint();\r\n  \r\n        // Calculate dimensions of sidebar, container and viewport.\r\n        this.calcDimensions();\r\n  \r\n        // Affix sidebar in proper position.\r\n        this.stickyPosition();\r\n  \r\n        // Bind all events.\r\n        this.bindEvents();\r\n        \r\n        // Inform other properties the sticky sidebar is initialized.\r\n        this._initialized = true;\r\n      }\r\n  \r\n      /**\r\n       * Bind all events of sticky sidebar plugin.\r\n       * @protected\r\n       */\r\n      bindEvents(){\r\n        window.addEventListener('resize', this, {passive: true, capture: false});\r\n        window.addEventListener('scroll', this, {passive: true, capture: false});\r\n  \r\n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\r\n          new ResizeSensor(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Handles all events of the plugin.\r\n       * @param {Object} event - Event object passed from listener.\r\n       */\r\n      handleEvent(event){\r\n        this.updateSticky(event);\r\n      }\r\n  \r\n      /**\r\n       * Calculates dimensions of sidebar, container and screen viewpoint\r\n       * @public\r\n       */\r\n      calcDimensions(){\r\n        if( this._breakpoint ) return;\r\n        var dims = this.dimensions;\r\n  \r\n        // Container of sticky sidebar dimensions.\r\n        dims.containerTop    = StickySidebar.offsetRelative(this.container).top;\r\n        dims.containerHeight = this.container.clientHeight;\r\n        dims.containerBottom = dims.containerTop + dims.containerHeight;\r\n  \r\n        // Sidebar dimensions.\r\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\r\n        dims.sidebarWidth  = this.sidebar.offsetWidth;\r\n        \r\n        // Screen viewport dimensions.\r\n        dims.viewportHeight = window.innerHeight;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n      }\r\n  \r\n      /**\r\n       * Some dimensions values need to be up-to-date when scrolling the page.\r\n       * @private\r\n       */\r\n      _calcDimensionsWithScroll(){\r\n        var dims = this.dimensions;\r\n  \r\n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\r\n  \r\n        dims.viewportTop    = document.documentElement.scrollTop || document.body.scrollTop;\r\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\r\n        dims.viewportLeft   = document.documentElement.scrollLeft || document.body.scrollLeft;\r\n  \r\n        dims.topSpacing    = this.options.topSpacing;\r\n        dims.bottomSpacing = this.options.bottomSpacing;\r\n  \r\n        if( 'function' === typeof dims.topSpacing )\r\n            dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\r\n  \r\n        if( 'function' === typeof dims.bottomSpacing )\r\n            dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\r\n        \r\n        if( 'VIEWPORT-TOP' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease top spacing value.\r\n          if( dims.topSpacing < dims.lastTopSpacing ){\r\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\r\n            this._reStyle = true; \r\n          }\r\n        \r\n        } else if( 'VIEWPORT-BOTTOM' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease bottom spacing value.\r\n          if( dims.bottomSpacing < dims.lastBottomSpacing ){\r\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\r\n            this._reStyle = true;\r\n          }\r\n        }\r\n        \r\n        dims.lastTopSpacing    = dims.topSpacing;\r\n        dims.lastBottomSpacing = dims.bottomSpacing;\r\n      }\r\n      \r\n      /**\r\n       * Determine whether the sidebar is bigger than viewport.\r\n       * @public\r\n       * @return {Boolean}\r\n       */\r\n      isSidebarFitsViewport(){\r\n        return this.dimensions.sidebarHeight < this.dimensions.viewportHeight;\r\n      }\r\n  \r\n      /**\r\n       * Observe browser scrolling direction top and down.\r\n       */\r\n      observeScrollDir(){\r\n        var dims = this.dimensions;\r\n        if( dims.lastViewportTop === dims.viewportTop ) return;\r\n  \r\n        var furthest = 'down' === this.direction ? Math.min : Math.max;\r\n        \r\n        // If the browser is scrolling not in the same direction.\r\n        if( dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop) )\r\n          this.direction = 'down' === this.direction ?  'up' : 'down';\r\n      }\r\n  \r\n      /**\r\n       * Gets affix type of sidebar according to current scrollTop and scrollLeft.\r\n       * Holds all logical affix of the sidebar when scrolling up and down and when sidebar \r\n       * is bigger than viewport and vice versa.\r\n       * @public\r\n       * @return {String|False} - Proper affix type.\r\n       */\r\n      getAffixType(){\r\n        var dims = this.dimensions, affixType = false;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n  \r\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\r\n        var colliderTop = dims.viewportTop + dims.topSpacing;\r\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\r\n  \r\n        // When browser is scrolling top.\r\n        if( 'up' === this.direction ){\r\n          if( colliderTop <= dims.containerTop ){\r\n            dims.translateY = 0;\r\n            affixType = 'STATIC';\r\n  \r\n          } else if( colliderTop <= dims.translateY + dims.containerTop ){\r\n            dims.translateY = colliderTop - dims.containerTop;\r\n            affixType = 'VIEWPORT-TOP';\r\n  \r\n          } else if( ! this.isSidebarFitsViewport() && dims.containerTop <= colliderTop ){\r\n            affixType = 'VIEWPORT-UNBOTTOM';\r\n          }\r\n        // When browser is scrolling up.\r\n        } else {\r\n          // When sidebar element is not bigger than screen viewport.\r\n          if( this.isSidebarFitsViewport() ){\r\n  \r\n            if( dims.sidebarHeight + colliderTop >= dims.containerBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom;\r\n              affixType = 'CONTAINER-BOTTOM'; \r\n  \r\n            } else if( colliderTop >= dims.containerTop ){\r\n              dims.translateY = colliderTop - dims.containerTop;\r\n              affixType = 'VIEWPORT-TOP';\r\n            }\r\n          // When sidebar element is bigger than screen viewport.\r\n          } else {\r\n      \r\n            if( dims.containerBottom <= colliderBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom; \r\n              affixType = 'CONTAINER-BOTTOM';    \r\n  \r\n            } else if( sidebarBottom + dims.translateY <= colliderBottom ){\r\n              dims.translateY = colliderBottom - sidebarBottom;\r\n              affixType = 'VIEWPORT-BOTTOM';\r\n            \r\n            } else if( dims.containerTop + dims.translateY <= colliderTop ){\r\n              affixType = 'VIEWPORT-UNBOTTOM';\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Make sure the translate Y is not bigger than container height.\r\n        dims.translateY = Math.max(0, dims.translateY);\r\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\r\n  \r\n        dims.lastViewportTop = dims.viewportTop;\r\n        return affixType;\r\n      }\r\n  \r\n      /**\r\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \r\n       * to its affix type.\r\n       * @private\r\n       * @param {String} affixType - Affix type of sticky sidebar.\r\n       * @return {Object}\r\n       */\r\n      _getStyle(affixType){\r\n        if( 'undefined' === typeof affixType ) return;\r\n  \r\n        var style = {inner: {}, outer: {}};\r\n        var dims = this.dimensions;\r\n  \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n            style.inner = {position: 'fixed', top: dims.topSpacing,\r\n                  left: dims.sidebarLeft - dims.viewportLeft, width: dims.sidebarWidth};\r\n            break;\r\n          case 'VIEWPORT-BOTTOM':\r\n            style.inner = {position: 'fixed', top: 'auto', left: dims.sidebarLeft,\r\n                  bottom: dims.bottomSpacing, width: dims.sidebarWidth};\r\n            break;\r\n          case 'CONTAINER-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n            let translate = this._getTranslate(0, dims.translateY + 'px');\r\n            \r\n            if( translate )\r\n              style.inner = {transform: translate};\r\n            else \r\n              style.inner = {position: 'absolute', top: dims.translateY, width: dims.sidebarWidth};\r\n            break;\r\n        }\r\n        \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n          case 'VIEWPORT-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n          case 'CONTAINER-BOTTOM':\r\n            style.outer = {height: dims.sidebarHeight, position: 'relative'};\r\n            break;\r\n        }\r\n  \r\n        style.outer = StickySidebar.extend({height: '', position: ''}, style.outer);\r\n        style.inner = StickySidebar.extend({position: 'relative', top: '', left: '',\r\n            bottom: '', width: '',  transform: this._getTranslate()}, style.inner);\r\n  \r\n        return style;\r\n      }\r\n     \r\n      /**\r\n       * Cause the sidebar to be sticky according to affix type by adding inline\r\n       * style, adding helper class and trigger events.\r\n       * @function\r\n       * @protected\r\n       * @param {string} force - Update sticky sidebar position by force.\r\n       */\r\n      stickyPosition(force){\r\n        if( this._breakpoint ) return;\r\n  \r\n        force = this._reStyle || force || false;\r\n        \r\n        var offsetTop = this.options.topSpacing;\r\n        var offsetBottom = this.options.bottomSpacing;\r\n  \r\n        var affixType = this.getAffixType();\r\n        var style = this._getStyle(affixType);\r\n        \r\n        if( (this.affixedType != affixType || force) && affixType ){\r\n          let affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\r\n  \r\n          if( 'STATIC' === affixType )\r\n            StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          else\r\n            StickySidebar.addClass(this.sidebar, this.options.stickyClass);\r\n          \r\n          for( let key in style.outer ){\r\n            let _unit = ('number' === typeof style.outer[key]) ? 'px' : '';\r\n            this.sidebar.style[key] = style.outer[key];\r\n          }\r\n  \r\n          for( let key in style.inner ){\r\n            let _unit = ('number' === typeof style.inner[key]) ? 'px' : '';\r\n            this.sidebarInner.style[key] = style.inner[key] + _unit;\r\n          }\r\n          \r\n          let affixedEvent = 'affixed.'+ affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\r\n        } else {\r\n          if( this._initialized ) this.sidebarInner.style.left = style.inner.left;\r\n        }\r\n  \r\n        this.affixedType = affixType;\r\n      }\r\n  \r\n      /**\r\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\r\n       * @protected\r\n       */\r\n      _widthBreakpoint(){\r\n  \r\n        if( window.innerWidth <= this.options.minWidth ){\r\n          this._breakpoint = true;\r\n          this.affixedType = 'STATIC';\r\n  \r\n          this.sidebar.removeAttribute('style');\r\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          this.sidebarInner.removeAttribute('style');\r\n        } else {\r\n          this._breakpoint = false;\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Switches between functions stack for each event type, if there's no \r\n       * event, it will re-initialize sticky sidebar.\r\n       * @public\r\n       */\r\n      updateSticky(event = {}){\r\n        if( this._running ) return;\r\n        this._running = true;\r\n  \r\n        ((eventType) => {\r\n\r\n          requestAnimationFrame(() => {\r\n            switch( eventType ){\r\n              // When browser is scrolling and re-calculate just dimensions\r\n              // within scroll. \r\n              case 'scroll':\r\n                this._calcDimensionsWithScroll();\r\n                this.observeScrollDir();\r\n                this.stickyPosition();\r\n                break;\r\n  \r\n              // When browser is resizing or there's no event, observe width\r\n              // breakpoint and re-calculate dimensions.\r\n              case 'resize':\r\n              default: \r\n                this._widthBreakpoint();\r\n                this.calcDimensions();\r\n                this.stickyPosition(true);\r\n                break;\r\n            }\r\n            this._running = false;\r\n          });\r\n        })(event.type);\r\n      }\r\n  \r\n      /**\r\n       * Set browser support features to the public property.\r\n       * @private\r\n       */\r\n      _setSupportFeatures(){\r\n        var support = this.support;\r\n  \r\n        support.transform = StickySidebar.supportTransform();\r\n        support.transform3d = StickySidebar.supportTransform(true);\r\n      }\r\n  \r\n      /**\r\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\r\n       * and the same with translate. if browser doesn't support both return false.\r\n       * @param {Number} y - Value of Y-axis.\r\n       * @param {Number} x - Value of X-axis.\r\n       * @param {Number} z - Value of Z-axis.\r\n       * @return {String|False}\r\n       */\r\n      _getTranslate(y = 0, x = 0, z = 0){\r\n        if( this.support.transform3d ) return 'translate3d(' + y +', '+ x +', '+ z +')';\r\n        else if( this.support.translate ) return 'translate('+ y +', '+ x +')';\r\n        else return false;\r\n      }\r\n  \r\n      /**\r\n       * Destroy sticky sidebar plugin.\r\n       * @public\r\n       */\r\n      destroy(){\r\n        window.removeEventListener('resize', this, {caption: false});\r\n        window.removeEventListener('scroll', this, {caption: false});\r\n  \r\n        this.sidebar.classList.remove(this.options.stickyClass);\r\n        this.sidebar.style.minHeight = '';\r\n  \r\n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\r\n  \r\n        var styleReset = {inner: {}, outer: {}};\r\n  \r\n        styleReset.inner = {position: '', top: '', left: '', bottom: '', width: '',  transform: ''};\r\n        styleReset.outer = {height: '', position: ''};\r\n  \r\n        for( let key in styleReset.outer )\r\n          this.sidebar.style[key] = styleReset.outer[key];\r\n  \r\n        for( let key in styleReset.inner )\r\n          this.sidebarInner.style[key] = styleReset.inner[key];\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\r\n          ResizeSensor.detach(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Determine if the browser supports CSS transform feature.\r\n       * @function\r\n       * @static\r\n       * @param {Boolean} transform3d - Detect transform with translate3d.\r\n       * @return {String}\r\n       */\r\n      static supportTransform(transform3d){\r\n        var result = false,\r\n            property = (transform3d) ? 'perspective' : 'transform',\r\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\r\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\r\n            support = document.createElement('support'),\r\n            style = support.style;\r\n  \r\n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function(property, i) {\r\n          if (style[property] !== undefined) {\r\n            result = property;\r\n            return false;\r\n          }\r\n        });\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Trigger custom event.\r\n       * @static\r\n       * @param {DOMObject} element - Target element on the DOM.\r\n       * @param {String} eventName - Event name.\r\n       * @param {Object} data - \r\n       */\r\n      static eventTrigger(element, eventName, data){\r\n        try{\r\n          var event = new CustomEvent(eventName, {detail: data});\r\n        } catch(e){\r\n          var event = document.createEvent('CustomEvent');\r\n          event.initCustomEvent(eventName, true, true, data);\r\n        }\r\n        element.dispatchEvent(event);\r\n      }\r\n  \r\n      /**\r\n       * Extend options object with defaults.\r\n       * @function\r\n       * @static\r\n       */\r\n      static extend(defaults, options){\r\n        var results = {};\r\n        for( let key in defaults ){\r\n          if( 'undefined' !== typeof options[key] ) results[key] = options[key];\r\n          else results[key] = defaults[key];\r\n        }\r\n        return results;\r\n      }\r\n  \r\n      /**\r\n       * Get current coordinates left and top of specific element.\r\n       * @static\r\n       */\r\n      static offsetRelative(element){\r\n        var result = {left: 0, top: 0};\r\n\r\n        do{\r\n          let offsetTop = element.offsetTop;\r\n          let offsetLeft = element.offsetLeft;\r\n  \r\n          if( ! isNaN(offsetTop) )\r\n            result.top += offsetTop;\r\n  \r\n          if( ! isNaN(offsetLeft) )\r\n            result.left += offsetLeft;\r\n\r\n          element = ( 'BODY' === element.tagName ) ?\r\n                      element.parentElement : element.offsetParent;\r\n        } while(element)\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Add specific class name to specific element.\r\n       * @static \r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static addClass(element, className){\r\n        if( ! StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.add(className);\r\n          else\r\n            element.className += ' ' + className;\r\n        }\r\n      }\r\n      \r\n      /**\r\n       * Remove specific class name to specific element\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static removeClass(element, className){\r\n        if( StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.remove(className);\r\n          else\r\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Determine weather the element has specific class name.\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static hasClass(element, className){\r\n        if (element.classList)\r\n          return element.classList.contains(className);\r\n        else\r\n          return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\r\n      }\r\n    }\r\n  \r\n    return StickySidebar;\r\n  })();\r\n  \r\n  /* harmony default export */ __webpack_exports__[\"default\"] = (StickySidebar);\r\n  \r\n  // Global\r\n  // -------------------------\r\n  window.StickySidebar = StickySidebar;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3N0aWNreS1zaWRlYmFyL3NyYy9zdGlja3ktc2lkZWJhci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9GOi9odG1sL2V3YWxsZXQvbm9kZV9tb2R1bGVzL3N0aWNreS1zaWRlYmFyL3NyYy9zdGlja3ktc2lkZWJhci5qcz85MTZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdGlja3kgU2lkZWJhciBKYXZhU2NyaXB0IFBsdWdpbi5cclxuICogQHZlcnNpb24gMy4zLjFcclxuICogQGF1dGhvciBBaG1lZCBCb3VodW9saWEgPGEuYm91aHVvbGlhQGdtYWlsLmNvbT5cclxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqL1xyXG5jb25zdCBTdGlja3lTaWRlYmFyID0gKCgpID0+IHtcclxuICBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gIyBEZWZpbmUgQ29uc3RhbnRzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vXHJcbiAgICBjb25zdCBFVkVOVF9LRVkgPSAnLnN0aWNreVNpZGViYXInO1xyXG4gICAgY29uc3QgVkVSU0lPTiAgID0gJzMuMy4xJztcclxuICBcclxuICAgIGNvbnN0IERFRkFVTFRTID0ge1xyXG4gICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEFkZGl0aW9uYWwgdG9wIHNwYWNpbmcgb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cclxuICAgICAgICogQHR5cGUge051bWVyaWN8RnVuY3Rpb259XHJcbiAgICAgICAqL1xyXG4gICAgICB0b3BTcGFjaW5nOiAwLFxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogQWRkaXRpb25hbCBib3R0b20gc3BhY2luZyBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxyXG4gICAgICAgKiBAdHlwZSB7TnVtZXJpY3xGdW5jdGlvbn1cclxuICAgICAgICovXHJcbiAgICAgIGJvdHRvbVNwYWNpbmc6IDAsXHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDb250YWluZXIgc2lkZWJhciBzZWxlY3RvciB0byBrbm93IHdoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHN0aWNreSBlbGVtZW50LlxyXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfEZhbHNlfVxyXG4gICAgICAgKi9cclxuICAgICAgY29udGFpbmVyU2VsZWN0b3I6IGZhbHNlLFxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogSW5uZXIgd3JhcHBlciBzZWxlY3Rvci5cclxuICAgICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAgICovXHJcbiAgICAgIGlubmVyV3JhcHBlclNlbGVjdG9yOiAnLmlubmVyLXdyYXBwZXItc3RpY2t5JyxcclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBuYW1lIG9mIENTUyBjbGFzcyB0byBhcHBseSB0byBlbGVtZW50cyB3aGVuIHRoZXkgaGF2ZSBiZWNvbWUgc3R1Y2suXHJcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd8RmFsc2V9XHJcbiAgICAgICAqL1xyXG4gICAgICBzdGlja3lDbGFzczogJ2lzLWFmZml4ZWQnLFxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogRGV0ZWN0IHdoZW4gc2lkZWJhciBhbmQgaXRzIGNvbnRhaW5lciBjaGFuZ2UgaGVpZ2h0IHNvIHJlLWNhbGN1bGF0ZSB0aGVpciBkaW1lbnNpb25zLlxyXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAgICovXHJcbiAgICAgIHJlc2l6ZVNlbnNvcjogdHJ1ZSxcclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBzaWRlYmFyIHJldHVybnMgdG8gaXRzIG5vcm1hbCBwb3NpdGlvbiBpZiBpdHMgd2lkdGggYmVsb3cgdGhpcyB2YWx1ZS5cclxuICAgICAgICogQHR5cGUge051bWVyaWN9XHJcbiAgICAgICAqL1xyXG4gICAgICBtaW5XaWR0aDogZmFsc2VcclxuICAgIH07XHJcbiAgXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vICMgQ2xhc3MgRGVmaW5pdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGlja3kgU2lkZWJhciBDbGFzcy5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgY2xhc3MgU3RpY2t5U2lkZWJhcntcclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFN0aWNreSBTaWRlYmFyIENvbnN0cnVjdG9yLlxyXG4gICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHNpZGViYXIgLSBUaGUgc2lkZWJhciBlbGVtZW50IG9yIHNpZGViYXIgc2VsZWN0b3IuXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2Ygc3RpY2t5IHNpZGViYXIuXHJcbiAgICAgICAqL1xyXG4gICAgICBjb25zdHJ1Y3RvcihzaWRlYmFyLCBvcHRpb25zID0ge30pe1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFN0aWNreVNpZGViYXIuZXh0ZW5kKERFRkFVTFRTLCBvcHRpb25zKTtcclxuICBcclxuICAgICAgICAvLyBTaWRlYmFyIGVsZW1lbnQgcXVlcnkgaWYgdGhlcmUncyBubyBvbmUsIHRocm93IGVycm9yLlxyXG4gICAgICAgIHRoaXMuc2lkZWJhciA9ICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNpZGViYXIgKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2lkZWJhcikgOiBzaWRlYmFyO1xyXG4gICAgICAgIGlmKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMuc2lkZWJhciApXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzcGVjaWZpYyBzaWRlYmFyIGVsZW1lbnQuXCIpO1xyXG4gIFxyXG4gICAgICAgIHRoaXMuc2lkZWJhcklubmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLnNpZGViYXIucGFyZW50RWxlbWVudDtcclxuICBcclxuICAgICAgICAvLyBDdXJyZW50IEFmZml4IFR5cGUgb2Ygc2lkZWJhciBlbGVtZW50LlxyXG4gICAgICAgIHRoaXMuYWZmaXhlZFR5cGUgPSAnU1RBVElDJztcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdkb3duJztcclxuICAgICAgICB0aGlzLnN1cHBvcnQgPSB7XHJcbiAgICAgICAgICB0cmFuc2Zvcm06ICAgZmFsc2UsXHJcbiAgICAgICAgICB0cmFuc2Zvcm0zZDogZmFsc2VcclxuICAgICAgICB9O1xyXG4gIFxyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVTdHlsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNpemVMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEaW1lbnNpb25zIG9mIHNpZGViYXIsIGNvbnRhaW5lciBhbmQgc2NyZWVuIHZpZXdwb3J0LlxyXG4gICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcclxuICAgICAgICAgIHRyYW5zbGF0ZVk6IDAsXHJcbiAgICAgICAgICB0b3BTcGFjaW5nOiAwLFxyXG4gICAgICAgICAgbGFzdFRvcFNwYWNpbmc6IDAsXHJcbiAgICAgICAgICBib3R0b21TcGFjaW5nOiAwLFxyXG4gICAgICAgICAgbGFzdEJvdHRvbVNwYWNpbmc6IDAsXHJcbiAgICAgICAgICBzaWRlYmFySGVpZ2h0OiAwLFxyXG4gICAgICAgICAgc2lkZWJhcldpZHRoOiAwLFxyXG4gICAgICAgICAgY29udGFpbmVyVG9wOiAwLFxyXG4gICAgICAgICAgY29udGFpbmVySGVpZ2h0OiAwLFxyXG4gICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IDAsXHJcbiAgICAgICAgICB2aWV3cG9ydFRvcDogMCwgXHJcbiAgICAgICAgICBsYXN0Vmlld3BvcnRUb3A6IDAsXHJcbiAgICAgICAgfTtcclxuICBcclxuICAgICAgICAvLyBCaW5kIGV2ZW50IGhhbmRsZXJzIGZvciByZWZlcmVuY2FiaWxpdHkuXHJcbiAgICAgICAgWydoYW5kbGVFdmVudCddLmZvckVhY2goIChtZXRob2QpID0+IHtcclxuICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IHRoaXNbbWV0aG9kXS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gIFxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3RpY2t5IHNpZGViYXIgZm9yIGZpcnN0IHRpbWUuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgc2lkZWJhciBieSBhZGRpbmcgaW5uZXIgd3JhcHBlciwgZGVmaW5lIGl0cyBjb250YWluZXIsIFxyXG4gICAgICAgKiBtaW4td2lkdGggYnJlYWtwb2ludCwgY2FsY3VsYXRpbmcgZGltZW5zaW9ucywgYWRkaW5nIGhlbHBlciBjbGFzc2VzIGFuZCBpbmxpbmUgc3R5bGUuXHJcbiAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAqL1xyXG4gICAgICBpbml0aWFsaXplKCl7XHJcbiAgICAgICAgdGhpcy5fc2V0U3VwcG9ydEZlYXR1cmVzKCk7XHJcbiAgXHJcbiAgICAgICAgLy8gR2V0IHN0aWNreSBzaWRlYmFyIGlubmVyIHdyYXBwZXIsIGlmIG5vdCBmb3VuZCwgd2lsbCBjcmVhdGUgb25lLlxyXG4gICAgICAgIGlmKCB0aGlzLm9wdGlvbnMuaW5uZXJXcmFwcGVyU2VsZWN0b3IgKXtcclxuICAgICAgICAgIHRoaXMuc2lkZWJhcklubmVyID0gdGhpcy5zaWRlYmFyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmlubmVyV3JhcHBlclNlbGVjdG9yKTtcclxuICBcclxuICAgICAgICAgIGlmKCBudWxsID09PSB0aGlzLnNpZGViYXJJbm5lciApXHJcbiAgICAgICAgICAgIHRoaXMuc2lkZWJhcklubmVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKCAhIHRoaXMuc2lkZWJhcklubmVyICl7XHJcbiAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2lubmVyLXdyYXBwZXItc3RpY2t5Jyk7XHJcbiAgICAgICAgICB0aGlzLnNpZGViYXIuYXBwZW5kQ2hpbGQod3JhcHBlcik7XHJcbiAgXHJcbiAgICAgICAgICB3aGlsZSggdGhpcy5zaWRlYmFyLmZpcnN0Q2hpbGQgIT0gd3JhcHBlciApXHJcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyLmZpcnN0Q2hpbGQpO1xyXG4gIFxyXG4gICAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIgPSB0aGlzLnNpZGViYXIucXVlcnlTZWxlY3RvcignLmlubmVyLXdyYXBwZXItc3RpY2t5Jyk7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIC8vIENvbnRhaW5lciB3cmFwcGVyIG9mIHRoZSBzaWRlYmFyLlxyXG4gICAgICAgIGlmKCB0aGlzLm9wdGlvbnMuY29udGFpbmVyU2VsZWN0b3IgKXtcclxuICAgICAgICAgIGxldCBjb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuY29udGFpbmVyU2VsZWN0b3IpO1xyXG4gICAgICAgICAgY29udGFpbmVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRhaW5lcnMpO1xyXG4gIFxyXG4gICAgICAgICAgY29udGFpbmVycy5mb3JFYWNoKChjb250YWluZXIsIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgaWYoICEgY29udGFpbmVyLmNvbnRhaW5zKHRoaXMuc2lkZWJhcikgKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgICAgfSk7XHJcbiAgXHJcbiAgICAgICAgICBpZiggISBjb250YWluZXJzLmxlbmd0aCApXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb250YWluZXIgZG9lcyBub3QgY29udGFpbnMgb24gdGhlIHNpZGViYXIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiB0b3AvYm90dG9tIHNwYWNpbmcgaXMgbm90IGZ1bmN0aW9uIHBhcnNlIHZhbHVlIHRvIGludGVnZXIuXHJcbiAgICAgICAgaWYoICdmdW5jdGlvbicgIT09IHR5cGVvZiB0aGlzLm9wdGlvbnMudG9wU3BhY2luZyApXHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudG9wU3BhY2luZyA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy50b3BTcGFjaW5nKSB8fCAwO1xyXG4gIFxyXG4gICAgICAgIGlmKCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcgKVxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZykgfHwgMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gQnJlYWtkb3duIHN0aWNreSBzaWRlYmFyIGlmIHNjcmVlbiB3aWR0aCBiZWxvdyBgb3B0aW9ucy5taW5XaWR0aGAuXHJcbiAgICAgICAgdGhpcy5fd2lkdGhCcmVha3BvaW50KCk7XHJcbiAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbnMgb2Ygc2lkZWJhciwgY29udGFpbmVyIGFuZCB2aWV3cG9ydC5cclxuICAgICAgICB0aGlzLmNhbGNEaW1lbnNpb25zKCk7XHJcbiAgXHJcbiAgICAgICAgLy8gQWZmaXggc2lkZWJhciBpbiBwcm9wZXIgcG9zaXRpb24uXHJcbiAgICAgICAgdGhpcy5zdGlja3lQb3NpdGlvbigpO1xyXG4gIFxyXG4gICAgICAgIC8vIEJpbmQgYWxsIGV2ZW50cy5cclxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJbmZvcm0gb3RoZXIgcHJvcGVydGllcyB0aGUgc3RpY2t5IHNpZGViYXIgaXMgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBCaW5kIGFsbCBldmVudHMgb2Ygc3RpY2t5IHNpZGViYXIgcGx1Z2luLlxyXG4gICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAqL1xyXG4gICAgICBiaW5kRXZlbnRzKCl7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMsIHtwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZX0pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB7cGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogZmFsc2V9KTtcclxuICBcclxuICAgICAgICB0aGlzLnNpZGViYXIuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlJyArIEVWRU5UX0tFWSwgdGhpcyk7XHJcbiAgXHJcbiAgICAgICAgaWYoIHRoaXMub3B0aW9ucy5yZXNpemVTZW5zb3IgJiYgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBSZXNpemVTZW5zb3IgKXtcclxuICAgICAgICAgIG5ldyBSZXNpemVTZW5zb3IodGhpcy5zaWRlYmFySW5uZXIsIHRoaXMuaGFuZGxlRXZlbnQpO1xyXG4gICAgICAgICAgbmV3IFJlc2l6ZVNlbnNvcih0aGlzLmNvbnRhaW5lciwgdGhpcy5oYW5kbGVFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBIYW5kbGVzIGFsbCBldmVudHMgb2YgdGhlIHBsdWdpbi5cclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0IHBhc3NlZCBmcm9tIGxpc3RlbmVyLlxyXG4gICAgICAgKi9cclxuICAgICAgaGFuZGxlRXZlbnQoZXZlbnQpe1xyXG4gICAgICAgIHRoaXMudXBkYXRlU3RpY2t5KGV2ZW50KTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogQ2FsY3VsYXRlcyBkaW1lbnNpb25zIG9mIHNpZGViYXIsIGNvbnRhaW5lciBhbmQgc2NyZWVuIHZpZXdwb2ludFxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqL1xyXG4gICAgICBjYWxjRGltZW5zaW9ucygpe1xyXG4gICAgICAgIGlmKCB0aGlzLl9icmVha3BvaW50ICkgcmV0dXJuO1xyXG4gICAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1lbnNpb25zO1xyXG4gIFxyXG4gICAgICAgIC8vIENvbnRhaW5lciBvZiBzdGlja3kgc2lkZWJhciBkaW1lbnNpb25zLlxyXG4gICAgICAgIGRpbXMuY29udGFpbmVyVG9wICAgID0gU3RpY2t5U2lkZWJhci5vZmZzZXRSZWxhdGl2ZSh0aGlzLmNvbnRhaW5lcikudG9wO1xyXG4gICAgICAgIGRpbXMuY29udGFpbmVySGVpZ2h0ID0gdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIGRpbXMuY29udGFpbmVyQm90dG9tID0gZGltcy5jb250YWluZXJUb3AgKyBkaW1zLmNvbnRhaW5lckhlaWdodDtcclxuICBcclxuICAgICAgICAvLyBTaWRlYmFyIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgZGltcy5zaWRlYmFySGVpZ2h0ID0gdGhpcy5zaWRlYmFySW5uZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIGRpbXMuc2lkZWJhcldpZHRoICA9IHRoaXMuc2lkZWJhci5vZmZzZXRXaWR0aDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTY3JlZW4gdmlld3BvcnQgZGltZW5zaW9ucy5cclxuICAgICAgICBkaW1zLnZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gIFxyXG4gICAgICAgIHRoaXMuX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTb21lIGRpbWVuc2lvbnMgdmFsdWVzIG5lZWQgdG8gYmUgdXAtdG8tZGF0ZSB3aGVuIHNjcm9sbGluZyB0aGUgcGFnZS5cclxuICAgICAgICogQHByaXZhdGVcclxuICAgICAgICovXHJcbiAgICAgIF9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGwoKXtcclxuICAgICAgICB2YXIgZGltcyA9IHRoaXMuZGltZW5zaW9ucztcclxuICBcclxuICAgICAgICBkaW1zLnNpZGViYXJMZWZ0ID0gU3RpY2t5U2lkZWJhci5vZmZzZXRSZWxhdGl2ZSh0aGlzLnNpZGViYXIpLmxlZnQ7XHJcbiAgXHJcbiAgICAgICAgZGltcy52aWV3cG9ydFRvcCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XHJcbiAgICAgICAgZGltcy52aWV3cG9ydEJvdHRvbSA9IGRpbXMudmlld3BvcnRUb3AgKyBkaW1zLnZpZXdwb3J0SGVpZ2h0O1xyXG4gICAgICAgIGRpbXMudmlld3BvcnRMZWZ0ICAgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XHJcbiAgXHJcbiAgICAgICAgZGltcy50b3BTcGFjaW5nICAgID0gdGhpcy5vcHRpb25zLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgZGltcy5ib3R0b21TcGFjaW5nID0gdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmc7XHJcbiAgXHJcbiAgICAgICAgaWYoICdmdW5jdGlvbicgPT09IHR5cGVvZiBkaW1zLnRvcFNwYWNpbmcgKVxyXG4gICAgICAgICAgICBkaW1zLnRvcFNwYWNpbmcgPSBwYXJzZUludChkaW1zLnRvcFNwYWNpbmcodGhpcy5zaWRlYmFyKSkgfHwgMDtcclxuICBcclxuICAgICAgICBpZiggJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRpbXMuYm90dG9tU3BhY2luZyApXHJcbiAgICAgICAgICAgIGRpbXMuYm90dG9tU3BhY2luZyA9IHBhcnNlSW50KGRpbXMuYm90dG9tU3BhY2luZyh0aGlzLnNpZGViYXIpKSB8fCAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKCAnVklFV1BPUlQtVE9QJyA9PT0gdGhpcy5hZmZpeGVkVHlwZSApe1xyXG4gICAgICAgICAgLy8gQWRqdXN0IHRyYW5zbGF0ZSBZIGluIHRoZSBjYXNlIGRlY3JlYXNlIHRvcCBzcGFjaW5nIHZhbHVlLlxyXG4gICAgICAgICAgaWYoIGRpbXMudG9wU3BhY2luZyA8IGRpbXMubGFzdFRvcFNwYWNpbmcgKXtcclxuICAgICAgICAgICAgZGltcy50cmFuc2xhdGVZICs9IGRpbXMubGFzdFRvcFNwYWNpbmcgLSBkaW1zLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlU3R5bGUgPSB0cnVlOyBcclxuICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB9IGVsc2UgaWYoICdWSUVXUE9SVC1CT1RUT00nID09PSB0aGlzLmFmZml4ZWRUeXBlICl7XHJcbiAgICAgICAgICAvLyBBZGp1c3QgdHJhbnNsYXRlIFkgaW4gdGhlIGNhc2UgZGVjcmVhc2UgYm90dG9tIHNwYWNpbmcgdmFsdWUuXHJcbiAgICAgICAgICBpZiggZGltcy5ib3R0b21TcGFjaW5nIDwgZGltcy5sYXN0Qm90dG9tU3BhY2luZyApe1xyXG4gICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgKz0gZGltcy5sYXN0Qm90dG9tU3BhY2luZyAtIGRpbXMuYm90dG9tU3BhY2luZztcclxuICAgICAgICAgICAgdGhpcy5fcmVTdHlsZSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGRpbXMubGFzdFRvcFNwYWNpbmcgICAgPSBkaW1zLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgZGltcy5sYXN0Qm90dG9tU3BhY2luZyA9IGRpbXMuYm90dG9tU3BhY2luZztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzaWRlYmFyIGlzIGJpZ2dlciB0aGFuIHZpZXdwb3J0LlxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgICAqL1xyXG4gICAgICBpc1NpZGViYXJGaXRzVmlld3BvcnQoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLnNpZGViYXJIZWlnaHQgPCB0aGlzLmRpbWVuc2lvbnMudmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIE9ic2VydmUgYnJvd3NlciBzY3JvbGxpbmcgZGlyZWN0aW9uIHRvcCBhbmQgZG93bi5cclxuICAgICAgICovXHJcbiAgICAgIG9ic2VydmVTY3JvbGxEaXIoKXtcclxuICAgICAgICB2YXIgZGltcyA9IHRoaXMuZGltZW5zaW9ucztcclxuICAgICAgICBpZiggZGltcy5sYXN0Vmlld3BvcnRUb3AgPT09IGRpbXMudmlld3BvcnRUb3AgKSByZXR1cm47XHJcbiAgXHJcbiAgICAgICAgdmFyIGZ1cnRoZXN0ID0gJ2Rvd24nID09PSB0aGlzLmRpcmVjdGlvbiA/IE1hdGgubWluIDogTWF0aC5tYXg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgaXMgc2Nyb2xsaW5nIG5vdCBpbiB0aGUgc2FtZSBkaXJlY3Rpb24uXHJcbiAgICAgICAgaWYoIGRpbXMudmlld3BvcnRUb3AgPT09IGZ1cnRoZXN0KGRpbXMudmlld3BvcnRUb3AsIGRpbXMubGFzdFZpZXdwb3J0VG9wKSApXHJcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9ICdkb3duJyA9PT0gdGhpcy5kaXJlY3Rpb24gPyAgJ3VwJyA6ICdkb3duJztcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0cyBhZmZpeCB0eXBlIG9mIHNpZGViYXIgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2Nyb2xsVG9wIGFuZCBzY3JvbGxMZWZ0LlxyXG4gICAgICAgKiBIb2xkcyBhbGwgbG9naWNhbCBhZmZpeCBvZiB0aGUgc2lkZWJhciB3aGVuIHNjcm9sbGluZyB1cCBhbmQgZG93biBhbmQgd2hlbiBzaWRlYmFyIFxyXG4gICAgICAgKiBpcyBiaWdnZXIgdGhhbiB2aWV3cG9ydCBhbmQgdmljZSB2ZXJzYS5cclxuICAgICAgICogQHB1YmxpY1xyXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd8RmFsc2V9IC0gUHJvcGVyIGFmZml4IHR5cGUuXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRBZmZpeFR5cGUoKXtcclxuICAgICAgICB2YXIgZGltcyA9IHRoaXMuZGltZW5zaW9ucywgYWZmaXhUeXBlID0gZmFsc2U7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCk7XHJcbiAgXHJcbiAgICAgICAgdmFyIHNpZGViYXJCb3R0b20gPSBkaW1zLnNpZGViYXJIZWlnaHQgKyBkaW1zLmNvbnRhaW5lclRvcDtcclxuICAgICAgICB2YXIgY29sbGlkZXJUb3AgPSBkaW1zLnZpZXdwb3J0VG9wICsgZGltcy50b3BTcGFjaW5nO1xyXG4gICAgICAgIHZhciBjb2xsaWRlckJvdHRvbSA9IGRpbXMudmlld3BvcnRCb3R0b20gLSBkaW1zLmJvdHRvbVNwYWNpbmc7XHJcbiAgXHJcbiAgICAgICAgLy8gV2hlbiBicm93c2VyIGlzIHNjcm9sbGluZyB0b3AuXHJcbiAgICAgICAgaWYoICd1cCcgPT09IHRoaXMuZGlyZWN0aW9uICl7XHJcbiAgICAgICAgICBpZiggY29sbGlkZXJUb3AgPD0gZGltcy5jb250YWluZXJUb3AgKXtcclxuICAgICAgICAgICAgZGltcy50cmFuc2xhdGVZID0gMDtcclxuICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1NUQVRJQyc7XHJcbiAgXHJcbiAgICAgICAgICB9IGVsc2UgaWYoIGNvbGxpZGVyVG9wIDw9IGRpbXMudHJhbnNsYXRlWSArIGRpbXMuY29udGFpbmVyVG9wICl7XHJcbiAgICAgICAgICAgIGRpbXMudHJhbnNsYXRlWSA9IGNvbGxpZGVyVG9wIC0gZGltcy5jb250YWluZXJUb3A7XHJcbiAgICAgICAgICAgIGFmZml4VHlwZSA9ICdWSUVXUE9SVC1UT1AnO1xyXG4gIFxyXG4gICAgICAgICAgfSBlbHNlIGlmKCAhIHRoaXMuaXNTaWRlYmFyRml0c1ZpZXdwb3J0KCkgJiYgZGltcy5jb250YWluZXJUb3AgPD0gY29sbGlkZXJUb3AgKXtcclxuICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1ZJRVdQT1JULVVOQk9UVE9NJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAvLyBXaGVuIGJyb3dzZXIgaXMgc2Nyb2xsaW5nIHVwLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBXaGVuIHNpZGViYXIgZWxlbWVudCBpcyBub3QgYmlnZ2VyIHRoYW4gc2NyZWVuIHZpZXdwb3J0LlxyXG4gICAgICAgICAgaWYoIHRoaXMuaXNTaWRlYmFyRml0c1ZpZXdwb3J0KCkgKXtcclxuICBcclxuICAgICAgICAgICAgaWYoIGRpbXMuc2lkZWJhckhlaWdodCArIGNvbGxpZGVyVG9wID49IGRpbXMuY29udGFpbmVyQm90dG9tICl7XHJcbiAgICAgICAgICAgICAgZGltcy50cmFuc2xhdGVZID0gZGltcy5jb250YWluZXJCb3R0b20gLSBzaWRlYmFyQm90dG9tO1xyXG4gICAgICAgICAgICAgIGFmZml4VHlwZSA9ICdDT05UQUlORVItQk9UVE9NJzsgXHJcbiAgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggY29sbGlkZXJUb3AgPj0gZGltcy5jb250YWluZXJUb3AgKXtcclxuICAgICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSBjb2xsaWRlclRvcCAtIGRpbXMuY29udGFpbmVyVG9wO1xyXG4gICAgICAgICAgICAgIGFmZml4VHlwZSA9ICdWSUVXUE9SVC1UT1AnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBXaGVuIHNpZGViYXIgZWxlbWVudCBpcyBiaWdnZXIgdGhhbiBzY3JlZW4gdmlld3BvcnQuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICBcclxuICAgICAgICAgICAgaWYoIGRpbXMuY29udGFpbmVyQm90dG9tIDw9IGNvbGxpZGVyQm90dG9tICl7XHJcbiAgICAgICAgICAgICAgZGltcy50cmFuc2xhdGVZID0gZGltcy5jb250YWluZXJCb3R0b20gLSBzaWRlYmFyQm90dG9tOyBcclxuICAgICAgICAgICAgICBhZmZpeFR5cGUgPSAnQ09OVEFJTkVSLUJPVFRPTSc7ICAgIFxyXG4gIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHNpZGViYXJCb3R0b20gKyBkaW1zLnRyYW5zbGF0ZVkgPD0gY29sbGlkZXJCb3R0b20gKXtcclxuICAgICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSBjb2xsaWRlckJvdHRvbSAtIHNpZGViYXJCb3R0b207XHJcbiAgICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1ZJRVdQT1JULUJPVFRPTSc7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9IGVsc2UgaWYoIGRpbXMuY29udGFpbmVyVG9wICsgZGltcy50cmFuc2xhdGVZIDw9IGNvbGxpZGVyVG9wICl7XHJcbiAgICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1ZJRVdQT1JULVVOQk9UVE9NJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHRyYW5zbGF0ZSBZIGlzIG5vdCBiaWdnZXIgdGhhbiBjb250YWluZXIgaGVpZ2h0LlxyXG4gICAgICAgIGRpbXMudHJhbnNsYXRlWSA9IE1hdGgubWF4KDAsIGRpbXMudHJhbnNsYXRlWSk7XHJcbiAgICAgICAgZGltcy50cmFuc2xhdGVZID0gTWF0aC5taW4oZGltcy5jb250YWluZXJIZWlnaHQsIGRpbXMudHJhbnNsYXRlWSk7XHJcbiAgXHJcbiAgICAgICAgZGltcy5sYXN0Vmlld3BvcnRUb3AgPSBkaW1zLnZpZXdwb3J0VG9wO1xyXG4gICAgICAgIHJldHVybiBhZmZpeFR5cGU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldHMgaW5saW5lIHN0eWxlIG9mIHN0aWNreSBzaWRlYmFyIHdyYXBwZXIgYW5kIGlubmVyIHdyYXBwZXIgYWNjb3JkaW5nIFxyXG4gICAgICAgKiB0byBpdHMgYWZmaXggdHlwZS5cclxuICAgICAgICogQHByaXZhdGVcclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFmZml4VHlwZSAtIEFmZml4IHR5cGUgb2Ygc3RpY2t5IHNpZGViYXIuXHJcbiAgICAgICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgICAgICovXHJcbiAgICAgIF9nZXRTdHlsZShhZmZpeFR5cGUpe1xyXG4gICAgICAgIGlmKCAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIGFmZml4VHlwZSApIHJldHVybjtcclxuICBcclxuICAgICAgICB2YXIgc3R5bGUgPSB7aW5uZXI6IHt9LCBvdXRlcjoge319O1xyXG4gICAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1lbnNpb25zO1xyXG4gIFxyXG4gICAgICAgIHN3aXRjaCggYWZmaXhUeXBlICl7XHJcbiAgICAgICAgICBjYXNlICdWSUVXUE9SVC1UT1AnOlxyXG4gICAgICAgICAgICBzdHlsZS5pbm5lciA9IHtwb3NpdGlvbjogJ2ZpeGVkJywgdG9wOiBkaW1zLnRvcFNwYWNpbmcsXHJcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpbXMuc2lkZWJhckxlZnQgLSBkaW1zLnZpZXdwb3J0TGVmdCwgd2lkdGg6IGRpbXMuc2lkZWJhcldpZHRofTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdWSUVXUE9SVC1CT1RUT00nOlxyXG4gICAgICAgICAgICBzdHlsZS5pbm5lciA9IHtwb3NpdGlvbjogJ2ZpeGVkJywgdG9wOiAnYXV0bycsIGxlZnQ6IGRpbXMuc2lkZWJhckxlZnQsXHJcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogZGltcy5ib3R0b21TcGFjaW5nLCB3aWR0aDogZGltcy5zaWRlYmFyV2lkdGh9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ0NPTlRBSU5FUi1CT1RUT00nOlxyXG4gICAgICAgICAgY2FzZSAnVklFV1BPUlQtVU5CT1RUT00nOlxyXG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlID0gdGhpcy5fZ2V0VHJhbnNsYXRlKDAsIGRpbXMudHJhbnNsYXRlWSArICdweCcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoIHRyYW5zbGF0ZSApXHJcbiAgICAgICAgICAgICAgc3R5bGUuaW5uZXIgPSB7dHJhbnNmb3JtOiB0cmFuc2xhdGV9O1xyXG4gICAgICAgICAgICBlbHNlIFxyXG4gICAgICAgICAgICAgIHN0eWxlLmlubmVyID0ge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IGRpbXMudHJhbnNsYXRlWSwgd2lkdGg6IGRpbXMuc2lkZWJhcldpZHRofTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCggYWZmaXhUeXBlICl7XHJcbiAgICAgICAgICBjYXNlICdWSUVXUE9SVC1UT1AnOlxyXG4gICAgICAgICAgY2FzZSAnVklFV1BPUlQtQk9UVE9NJzpcclxuICAgICAgICAgIGNhc2UgJ1ZJRVdQT1JULVVOQk9UVE9NJzpcclxuICAgICAgICAgIGNhc2UgJ0NPTlRBSU5FUi1CT1RUT00nOlxyXG4gICAgICAgICAgICBzdHlsZS5vdXRlciA9IHtoZWlnaHQ6IGRpbXMuc2lkZWJhckhlaWdodCwgcG9zaXRpb246ICdyZWxhdGl2ZSd9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgc3R5bGUub3V0ZXIgPSBTdGlja3lTaWRlYmFyLmV4dGVuZCh7aGVpZ2h0OiAnJywgcG9zaXRpb246ICcnfSwgc3R5bGUub3V0ZXIpO1xyXG4gICAgICAgIHN0eWxlLmlubmVyID0gU3RpY2t5U2lkZWJhci5leHRlbmQoe3Bvc2l0aW9uOiAncmVsYXRpdmUnLCB0b3A6ICcnLCBsZWZ0OiAnJyxcclxuICAgICAgICAgICAgYm90dG9tOiAnJywgd2lkdGg6ICcnLCAgdHJhbnNmb3JtOiB0aGlzLl9nZXRUcmFuc2xhdGUoKX0sIHN0eWxlLmlubmVyKTtcclxuICBcclxuICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICAgIH1cclxuICAgICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIENhdXNlIHRoZSBzaWRlYmFyIHRvIGJlIHN0aWNreSBhY2NvcmRpbmcgdG8gYWZmaXggdHlwZSBieSBhZGRpbmcgaW5saW5lXHJcbiAgICAgICAqIHN0eWxlLCBhZGRpbmcgaGVscGVyIGNsYXNzIGFuZCB0cmlnZ2VyIGV2ZW50cy5cclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcmNlIC0gVXBkYXRlIHN0aWNreSBzaWRlYmFyIHBvc2l0aW9uIGJ5IGZvcmNlLlxyXG4gICAgICAgKi9cclxuICAgICAgc3RpY2t5UG9zaXRpb24oZm9yY2Upe1xyXG4gICAgICAgIGlmKCB0aGlzLl9icmVha3BvaW50ICkgcmV0dXJuO1xyXG4gIFxyXG4gICAgICAgIGZvcmNlID0gdGhpcy5fcmVTdHlsZSB8fCBmb3JjZSB8fCBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgb2Zmc2V0VG9wID0gdGhpcy5vcHRpb25zLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgdmFyIG9mZnNldEJvdHRvbSA9IHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nO1xyXG4gIFxyXG4gICAgICAgIHZhciBhZmZpeFR5cGUgPSB0aGlzLmdldEFmZml4VHlwZSgpO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2dldFN0eWxlKGFmZml4VHlwZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoICh0aGlzLmFmZml4ZWRUeXBlICE9IGFmZml4VHlwZSB8fCBmb3JjZSkgJiYgYWZmaXhUeXBlICl7XHJcbiAgICAgICAgICBsZXQgYWZmaXhFdmVudCA9ICdhZmZpeC4nICsgYWZmaXhUeXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgndmlld3BvcnQtJywgJycpICsgRVZFTlRfS0VZO1xyXG4gICAgICAgICAgU3RpY2t5U2lkZWJhci5ldmVudFRyaWdnZXIodGhpcy5zaWRlYmFyLCBhZmZpeEV2ZW50KTtcclxuICBcclxuICAgICAgICAgIGlmKCAnU1RBVElDJyA9PT0gYWZmaXhUeXBlIClcclxuICAgICAgICAgICAgU3RpY2t5U2lkZWJhci5yZW1vdmVDbGFzcyh0aGlzLnNpZGViYXIsIHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIFN0aWNreVNpZGViYXIuYWRkQ2xhc3ModGhpcy5zaWRlYmFyLCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb3IoIGxldCBrZXkgaW4gc3R5bGUub3V0ZXIgKXtcclxuICAgICAgICAgICAgbGV0IF91bml0ID0gKCdudW1iZXInID09PSB0eXBlb2Ygc3R5bGUub3V0ZXJba2V5XSkgPyAncHgnIDogJyc7XHJcbiAgICAgICAgICAgIHRoaXMuc2lkZWJhci5zdHlsZVtrZXldID0gc3R5bGUub3V0ZXJba2V5XTtcclxuICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgIGZvciggbGV0IGtleSBpbiBzdHlsZS5pbm5lciApe1xyXG4gICAgICAgICAgICBsZXQgX3VuaXQgPSAoJ251bWJlcicgPT09IHR5cGVvZiBzdHlsZS5pbm5lcltrZXldKSA/ICdweCcgOiAnJztcclxuICAgICAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIuc3R5bGVba2V5XSA9IHN0eWxlLmlubmVyW2tleV0gKyBfdW5pdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgbGV0IGFmZml4ZWRFdmVudCA9ICdhZmZpeGVkLicrIGFmZml4VHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3ZpZXdwb3J0LScsICcnKSArIEVWRU5UX0tFWTtcclxuICAgICAgICAgIFN0aWNreVNpZGViYXIuZXZlbnRUcmlnZ2VyKHRoaXMuc2lkZWJhciwgYWZmaXhlZEV2ZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYoIHRoaXMuX2luaXRpYWxpemVkICkgdGhpcy5zaWRlYmFySW5uZXIuc3R5bGUubGVmdCA9IHN0eWxlLmlubmVyLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIHRoaXMuYWZmaXhlZFR5cGUgPSBhZmZpeFR5cGU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEJyZWFrZG93biBzdGlja3kgc2lkZWJhciB3aGVuIHdpbmRvdyB3aWR0aCBpcyBiZWxvdyBgb3B0aW9ucy5taW5XaWR0aGAgdmFsdWUuXHJcbiAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICovXHJcbiAgICAgIF93aWR0aEJyZWFrcG9pbnQoKXtcclxuICBcclxuICAgICAgICBpZiggd2luZG93LmlubmVyV2lkdGggPD0gdGhpcy5vcHRpb25zLm1pbldpZHRoICl7XHJcbiAgICAgICAgICB0aGlzLl9icmVha3BvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgIHRoaXMuYWZmaXhlZFR5cGUgPSAnU1RBVElDJztcclxuICBcclxuICAgICAgICAgIHRoaXMuc2lkZWJhci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcbiAgICAgICAgICBTdGlja3lTaWRlYmFyLnJlbW92ZUNsYXNzKHRoaXMuc2lkZWJhciwgdGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKTtcclxuICAgICAgICAgIHRoaXMuc2lkZWJhcklubmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fYnJlYWtwb2ludCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogU3dpdGNoZXMgYmV0d2VlbiBmdW5jdGlvbnMgc3RhY2sgZm9yIGVhY2ggZXZlbnQgdHlwZSwgaWYgdGhlcmUncyBubyBcclxuICAgICAgICogZXZlbnQsIGl0IHdpbGwgcmUtaW5pdGlhbGl6ZSBzdGlja3kgc2lkZWJhci5cclxuICAgICAgICogQHB1YmxpY1xyXG4gICAgICAgKi9cclxuICAgICAgdXBkYXRlU3RpY2t5KGV2ZW50ID0ge30pe1xyXG4gICAgICAgIGlmKCB0aGlzLl9ydW5uaW5nICkgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gIFxyXG4gICAgICAgICgoZXZlbnRUeXBlKSA9PiB7XHJcblxyXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoKCBldmVudFR5cGUgKXtcclxuICAgICAgICAgICAgICAvLyBXaGVuIGJyb3dzZXIgaXMgc2Nyb2xsaW5nIGFuZCByZS1jYWxjdWxhdGUganVzdCBkaW1lbnNpb25zXHJcbiAgICAgICAgICAgICAgLy8gd2l0aGluIHNjcm9sbC4gXHJcbiAgICAgICAgICAgICAgY2FzZSAnc2Nyb2xsJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlU2Nyb2xsRGlyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0aWNreVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICBcclxuICAgICAgICAgICAgICAvLyBXaGVuIGJyb3dzZXIgaXMgcmVzaXppbmcgb3IgdGhlcmUncyBubyBldmVudCwgb2JzZXJ2ZSB3aWR0aFxyXG4gICAgICAgICAgICAgIC8vIGJyZWFrcG9pbnQgYW5kIHJlLWNhbGN1bGF0ZSBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICAgIGNhc2UgJ3Jlc2l6ZSc6XHJcbiAgICAgICAgICAgICAgZGVmYXVsdDogXHJcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aEJyZWFrcG9pbnQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY0RpbWVuc2lvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5UG9zaXRpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KShldmVudC50eXBlKTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogU2V0IGJyb3dzZXIgc3VwcG9ydCBmZWF0dXJlcyB0byB0aGUgcHVibGljIHByb3BlcnR5LlxyXG4gICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgKi9cclxuICAgICAgX3NldFN1cHBvcnRGZWF0dXJlcygpe1xyXG4gICAgICAgIHZhciBzdXBwb3J0ID0gdGhpcy5zdXBwb3J0O1xyXG4gIFxyXG4gICAgICAgIHN1cHBvcnQudHJhbnNmb3JtID0gU3RpY2t5U2lkZWJhci5zdXBwb3J0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgc3VwcG9ydC50cmFuc2Zvcm0zZCA9IFN0aWNreVNpZGViYXIuc3VwcG9ydFRyYW5zZm9ybSh0cnVlKTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0IHRyYW5zbGF0ZSB2YWx1ZSwgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNmcm9tM2QsIGl0IHdpbGwgYWRvcHQgaXQuXHJcbiAgICAgICAqIGFuZCB0aGUgc2FtZSB3aXRoIHRyYW5zbGF0ZS4gaWYgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgYm90aCByZXR1cm4gZmFsc2UuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVmFsdWUgb2YgWS1heGlzLlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFZhbHVlIG9mIFgtYXhpcy5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHogLSBWYWx1ZSBvZiBaLWF4aXMuXHJcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ3xGYWxzZX1cclxuICAgICAgICovXHJcbiAgICAgIF9nZXRUcmFuc2xhdGUoeSA9IDAsIHggPSAwLCB6ID0gMCl7XHJcbiAgICAgICAgaWYoIHRoaXMuc3VwcG9ydC50cmFuc2Zvcm0zZCApIHJldHVybiAndHJhbnNsYXRlM2QoJyArIHkgKycsICcrIHggKycsICcrIHogKycpJztcclxuICAgICAgICBlbHNlIGlmKCB0aGlzLnN1cHBvcnQudHJhbnNsYXRlICkgcmV0dXJuICd0cmFuc2xhdGUoJysgeSArJywgJysgeCArJyknO1xyXG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXN0cm95IHN0aWNreSBzaWRlYmFyIHBsdWdpbi5cclxuICAgICAgICogQHB1YmxpY1xyXG4gICAgICAgKi9cclxuICAgICAgZGVzdHJveSgpe1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLCB7Y2FwdGlvbjogZmFsc2V9KTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywge2NhcHRpb246IGZhbHNlfSk7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5zaWRlYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKTtcclxuICAgICAgICB0aGlzLnNpZGViYXIuc3R5bGUubWluSGVpZ2h0ID0gJyc7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5zaWRlYmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VwZGF0ZScgKyBFVkVOVF9LRVksIHRoaXMpO1xyXG4gIFxyXG4gICAgICAgIHZhciBzdHlsZVJlc2V0ID0ge2lubmVyOiB7fSwgb3V0ZXI6IHt9fTtcclxuICBcclxuICAgICAgICBzdHlsZVJlc2V0LmlubmVyID0ge3Bvc2l0aW9uOiAnJywgdG9wOiAnJywgbGVmdDogJycsIGJvdHRvbTogJycsIHdpZHRoOiAnJywgIHRyYW5zZm9ybTogJyd9O1xyXG4gICAgICAgIHN0eWxlUmVzZXQub3V0ZXIgPSB7aGVpZ2h0OiAnJywgcG9zaXRpb246ICcnfTtcclxuICBcclxuICAgICAgICBmb3IoIGxldCBrZXkgaW4gc3R5bGVSZXNldC5vdXRlciApXHJcbiAgICAgICAgICB0aGlzLnNpZGViYXIuc3R5bGVba2V5XSA9IHN0eWxlUmVzZXQub3V0ZXJba2V5XTtcclxuICBcclxuICAgICAgICBmb3IoIGxldCBrZXkgaW4gc3R5bGVSZXNldC5pbm5lciApXHJcbiAgICAgICAgICB0aGlzLnNpZGViYXJJbm5lci5zdHlsZVtrZXldID0gc3R5bGVSZXNldC5pbm5lcltrZXldO1xyXG4gIFxyXG4gICAgICAgIGlmKCB0aGlzLm9wdGlvbnMucmVzaXplU2Vuc29yICYmICd1bmRlZmluZWQnICE9PSB0eXBlb2YgUmVzaXplU2Vuc29yICl7XHJcbiAgICAgICAgICBSZXNpemVTZW5zb3IuZGV0YWNoKHRoaXMuc2lkZWJhcklubmVyLCB0aGlzLmhhbmRsZUV2ZW50KTtcclxuICAgICAgICAgIFJlc2l6ZVNlbnNvci5kZXRhY2godGhpcy5jb250YWluZXIsIHRoaXMuaGFuZGxlRXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIENTUyB0cmFuc2Zvcm0gZmVhdHVyZS5cclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSB0cmFuc2Zvcm0zZCAtIERldGVjdCB0cmFuc2Zvcm0gd2l0aCB0cmFuc2xhdGUzZC5cclxuICAgICAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAgICAgKi9cclxuICAgICAgc3RhdGljIHN1cHBvcnRUcmFuc2Zvcm0odHJhbnNmb3JtM2Qpe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZSxcclxuICAgICAgICAgICAgcHJvcGVydHkgPSAodHJhbnNmb3JtM2QpID8gJ3BlcnNwZWN0aXZlJyA6ICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICB1cHBlciA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSksXHJcbiAgICAgICAgICAgIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXSxcclxuICAgICAgICAgICAgc3VwcG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1cHBvcnQnKSxcclxuICAgICAgICAgICAgc3R5bGUgPSBzdXBwb3J0LnN0eWxlO1xyXG4gIFxyXG4gICAgICAgIChwcm9wZXJ0eSArICcgJyArIHByZWZpeGVzLmpvaW4odXBwZXIgKyAnICcpICsgdXBwZXIpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSwgaSkge1xyXG4gICAgICAgICAgaWYgKHN0eWxlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb3BlcnR5O1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogVHJpZ2dlciBjdXN0b20gZXZlbnQuXHJcbiAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICogQHBhcmFtIHtET01PYmplY3R9IGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudCBvbiB0aGUgRE9NLlxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIC0gRXZlbnQgbmFtZS5cclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBcclxuICAgICAgICovXHJcbiAgICAgIHN0YXRpYyBldmVudFRyaWdnZXIoZWxlbWVudCwgZXZlbnROYW1lLCBkYXRhKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7ZGV0YWlsOiBkYXRhfSk7XHJcbiAgICAgICAgfSBjYXRjaChlKXtcclxuICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEV4dGVuZCBvcHRpb25zIG9iamVjdCB3aXRoIGRlZmF1bHRzLlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgKi9cclxuICAgICAgc3RhdGljIGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyl7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuICAgICAgICBmb3IoIGxldCBrZXkgaW4gZGVmYXVsdHMgKXtcclxuICAgICAgICAgIGlmKCAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG9wdGlvbnNba2V5XSApIHJlc3VsdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgIGVsc2UgcmVzdWx0c1trZXldID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEdldCBjdXJyZW50IGNvb3JkaW5hdGVzIGxlZnQgYW5kIHRvcCBvZiBzcGVjaWZpYyBlbGVtZW50LlxyXG4gICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgb2Zmc2V0UmVsYXRpdmUoZWxlbWVudCl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xyXG5cclxuICAgICAgICBkb3tcclxuICAgICAgICAgIGxldCBvZmZzZXRUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgIGxldCBvZmZzZXRMZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0O1xyXG4gIFxyXG4gICAgICAgICAgaWYoICEgaXNOYU4ob2Zmc2V0VG9wKSApXHJcbiAgICAgICAgICAgIHJlc3VsdC50b3AgKz0gb2Zmc2V0VG9wO1xyXG4gIFxyXG4gICAgICAgICAgaWYoICEgaXNOYU4ob2Zmc2V0TGVmdCkgKVxyXG4gICAgICAgICAgICByZXN1bHQubGVmdCArPSBvZmZzZXRMZWZ0O1xyXG5cclxuICAgICAgICAgIGVsZW1lbnQgPSAoICdCT0RZJyA9PT0gZWxlbWVudC50YWdOYW1lICkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnRFbGVtZW50IDogZWxlbWVudC5vZmZzZXRQYXJlbnQ7XHJcbiAgICAgICAgfSB3aGlsZShlbGVtZW50KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEFkZCBzcGVjaWZpYyBjbGFzcyBuYW1lIHRvIHNwZWNpZmljIGVsZW1lbnQuXHJcbiAgICAgICAqIEBzdGF0aWMgXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0RE9NfSBlbGVtZW50IFxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIFxyXG4gICAgICAgKi9cclxuICAgICAgc3RhdGljIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSl7XHJcbiAgICAgICAgaWYoICEgU3RpY2t5U2lkZWJhci5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpICl7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuICAgICAgICogUmVtb3ZlIHNwZWNpZmljIGNsYXNzIG5hbWUgdG8gc3BlY2lmaWMgZWxlbWVudFxyXG4gICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0RE9NfSBlbGVtZW50IFxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIFxyXG4gICAgICAgKi9cclxuICAgICAgc3RhdGljIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSl7XHJcbiAgICAgICAgaWYoIFN0aWNreVNpZGViYXIuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSApe1xyXG4gICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KVxyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxiKScgKyBjbGFzc05hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKFxcXFxifCQpJywgJ2dpJyksICcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogRGV0ZXJtaW5lIHdlYXRoZXIgdGhlIGVsZW1lbnQgaGFzIHNwZWNpZmljIGNsYXNzIG5hbWUuXHJcbiAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICogQHBhcmFtIHtPYmplY3RET019IGVsZW1lbnQgXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKXtcclxuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpXHJcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKF58ICknICsgY2xhc3NOYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChlbGVtZW50LmNsYXNzTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIHJldHVybiBTdGlja3lTaWRlYmFyO1xyXG4gIH0pKCk7XHJcbiAgXHJcbiAgZXhwb3J0IGRlZmF1bHQgU3RpY2t5U2lkZWJhcjtcclxuICBcclxuICAvLyBHbG9iYWxcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgd2luZG93LlN0aWNreVNpZGViYXIgPSBTdGlja3lTaWRlYmFyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/sticky-sidebar/src/sticky-sidebar.js\n");

/***/ }),

/***/ "./components/resizeSensor.js":
/*!************************************!*\
  !*** ./components/resizeSensor.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\r\n * directory of this distribution and at\r\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\r\n */\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(typeof window !== 'undefined' ? window : undefined, function () {\n\n    // Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // https://github.com/Semantic-Org/Semantic-UI/issues/3855\n    // https://github.com/marcj/css-element-queries/issues/257\n    var globalWindow = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')();\n    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = globalWindow.requestAnimationFrame || globalWindow.mozRequestAnimationFrame || globalWindow.webkitRequestAnimationFrame || function (fn) {\n        return globalWindow.setTimeout(fn, 20);\n    };\n\n    /**\r\n     * Iterate over each of the provided element(s).\r\n     *\r\n     * @param {HTMLElement|HTMLElement[]} elements\r\n     * @param {Function}                  callback\r\n     */\n    function forEachElement(elements, callback) {\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = elementsType === '[object Array]' || elementsType === '[object NodeList]' || elementsType === '[object HTMLCollection]' || elementsType === '[object Object]' || typeof jQuery !== 'undefined' && elements instanceof jQuery // jquery\n        || typeof Elements !== 'undefined' && elements instanceof Elements // mootools\n        ;\n        var i = 0;var j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\r\n    * Get element size\r\n    * @param {HTMLElement} element\r\n    * @returns {Object} {width, height}\r\n    */\n    function getElementSize(element) {\n        if (!element.getBoundingClientRect) {\n            return {\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            };\n        }\n\n        var rect = element.getBoundingClientRect();\n        return {\n            width: Math.round(rect.width),\n            height: Math.round(rect.height)\n        };\n    }\n\n    /**\r\n     * Apply CSS styles to element.\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @param {Object} style\r\n     */\n    function setStyle(element, style) {\n        Object.keys(style).forEach(function (key) {\n            element.style[key] = style[key];\n        });\n    }\n\n    /**\r\n     * Class for dimension change detection.\r\n     *\r\n     * @param {Element|Element[]|Elements|jQuery} element\r\n     * @param {Function} callback\r\n     *\r\n     * @constructor\r\n     */\n    var ResizeSensor = function ResizeSensor(element, callback) {\n        /**\r\n         *\r\n         * @constructor\r\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function (ev) {\n                q.push(ev);\n            };\n\n            var i = void 0;var j;\n            this.call = function (sizeInfo) {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call(this, sizeInfo);\n                }\n            };\n\n            this.remove = function (ev) {\n                var newQueue = [];\n                for (i = 0, j = q.length; i < j; i++) {\n                    if (q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            };\n\n            this.length = function () {\n                return q.length;\n            };\n        }\n\n        /**\r\n         *\r\n         * @param {HTMLElement} element\r\n         * @param {Function}    resized\r\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element) return;\n            if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizedAttached = new EventQueue();\n            element.resizedAttached.add(resized);\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.dir = 'ltr';\n            element.resizeSensor.className = 'resize-sensor';\n\n            var style = {\n                pointerEvents: 'none',\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                right: '0px',\n                bottom: '0px',\n                overflow: 'hidden',\n                zIndex: '-1',\n                visibility: 'hidden',\n                maxWidth: '100%'\n            };\n            var styleChild = {\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                transition: '0s'\n            };\n\n            setStyle(element.resizeSensor, style);\n\n            var expand = document.createElement('div');\n            expand.className = 'resize-sensor-expand';\n            setStyle(expand, style);\n\n            var expandChild = document.createElement('div');\n            setStyle(expandChild, styleChild);\n            expand.appendChild(expandChild);\n\n            var shrink = document.createElement('div');\n            shrink.className = 'resize-sensor-shrink';\n            setStyle(shrink, style);\n\n            var shrinkChild = document.createElement('div');\n            setStyle(shrinkChild, styleChild);\n            setStyle(shrinkChild, { width: '200%', height: '200%' });\n            shrink.appendChild(shrinkChild);\n\n            element.resizeSensor.appendChild(expand);\n            element.resizeSensor.appendChild(shrink);\n            element.appendChild(element.resizeSensor);\n\n            var computedStyle = window.getComputedStyle(element);\n            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;\n            if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n                element.style.position = 'relative';\n            }\n\n            var dirty = void 0;var rafId;\n            var size = getElementSize(element);\n            var lastWidth = 0;\n            var lastHeight = 0;\n            var initialHiddenCheck = true;\n            var lastAnimationFrame = 0;\n\n            var resetExpandShrink = function resetExpandShrink() {\n                var width = element.offsetWidth;\n                var height = element.offsetHeight;\n\n                expandChild.style.width = width + 10 + \"px\";\n                expandChild.style.height = height + 10 + \"px\";\n\n                expand.scrollLeft = width + 10;\n                expand.scrollTop = height + 10;\n\n                shrink.scrollLeft = width + 10;\n                shrink.scrollTop = height + 10;\n            };\n\n            var reset = function reset() {\n                // Check if element is hidden\n                if (initialHiddenCheck) {\n                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;\n                    if (invisible) {\n                        // Check in next frame\n                        if (!lastAnimationFrame) {\n                            lastAnimationFrame = requestAnimationFrame(function () {\n                                lastAnimationFrame = 0;\n\n                                reset();\n                            });\n                        }\n\n                        return;\n                    }\n                    // Stop checking\n                    initialHiddenCheck = false;\n                }\n\n                resetExpandShrink();\n            };\n            element.resizeSensor.resetSensor = reset;\n\n            var onResized = function onResized() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = size.width;\n                lastHeight = size.height;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call(size);\n                }\n            };\n\n            var onScroll = function onScroll() {\n                size = getElementSize(element);\n                dirty = size.width !== lastWidth || size.height !== lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function addEvent(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent(\"on\" + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n\n            // Fix for custom Elements\n            requestAnimationFrame(reset);\n        }\n\n        forEachElement(element, function (elem) {\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function (ev) {\n            ResizeSensor.detach(element, ev);\n        };\n\n        this.reset = function () {\n            element.resizeSensor.resetSensor();\n        };\n    };\n\n    ResizeSensor.reset = function (element) {\n        forEachElement(element, function (elem) {\n            elem.resizeSensor.resetSensor();\n        });\n    };\n\n    ResizeSensor.detach = function (element, ev) {\n        forEachElement(element, function (elem) {\n            if (!elem) return;\n            if (elem.resizedAttached && typeof ev === \"function\") {\n                elem.resizedAttached.remove(ev);\n                if (elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    if (typeof MutationObserver !== \"undefined\") {\n        var observer = new MutationObserver(function (mutations) {\n            for (var i in mutations) {\n                if (mutations.hasOwnProperty(i)) {\n                    var items = mutations[i].addedNodes;\n                    for (var j = 0; j < items.length; j++) {\n                        if (items[j].resizeSensor) {\n                            ResizeSensor.reset(items[j]);\n                        }\n                    }\n                }\n            }\n        });\n\n        document.addEventListener(\"DOMContentLoaded\", function (event) {\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        });\n    }\n\n    return ResizeSensor;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3Jlc2l6ZVNlbnNvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9yZXNpemVTZW5zb3IuanM/ODYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXHJcbiAqIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgYXRcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5cclxuICovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290LlJlc2l6ZVNlbnNvciA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgZG9lcyBub3QgdGhyb3cgaW4gYSBTU1IgKFNlcnZlciBTaWRlIFJlbmRlcmluZykgc2l0dWF0aW9uXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1NlbWFudGljLU9yZy9TZW1hbnRpYy1VSS9pc3N1ZXMvMzg1NVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvaXNzdWVzLzI1N1xyXG4gICAgbGV0IGdsb2JhbFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcclxuICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoXHJcbiAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbiAgICAvLyBPbmx5IHVzZWQgZm9yIHRoZSBkaXJ0eSBjaGVja2luZywgc28gdGhlIGV2ZW50IGNhbGxiYWNrIGNvdW50IGlzIGxpbWl0ZWQgdG8gbWF4IDEgY2FsbCBwZXIgZnBzIHBlciBzZW5zb3IuXHJcbiAgICAvLyBJbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBldmVudCBiYXNlZCByZXNpemUgc2Vuc29yIHRoaXMgc2F2ZXMgY3B1IHRpbWUsIGJlY2F1c2UgdGhlIHNlbnNvciBpcyB0b28gZmFzdCBhbmRcclxuICAgIC8vIHdvdWxkIGdlbmVyYXRlIHRvbyBtYW55IHVubmVjZXNzYXJ5IGV2ZW50cy5cclxuICAgIGxldCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgZ2xvYmFsV2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIGdsb2JhbFdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFdpbmRvdy5zZXRUaW1lb3V0KGZuLCAyMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG9mIHRoZSBwcm92aWRlZCBlbGVtZW50KHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTEVsZW1lbnRbXX0gZWxlbWVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQoZWxlbWVudHMsIGNhbGxiYWNrKXtcclxuICAgICAgICBsZXQgZWxlbWVudHNUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnRzKTtcclxuICAgICAgICBsZXQgaXNDb2xsZWN0aW9uVHlwZWQgPSAoZWxlbWVudHNUeXBlID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScpXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKVxyXG4gICAgICAgICAgICB8fCAodHlwZW9mIGpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudHMgaW5zdGFuY2VvZiBqUXVlcnkpIC8vIGpxdWVyeVxyXG4gICAgICAgICAgICB8fCAodHlwZW9mIEVsZW1lbnRzICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50cyBpbnN0YW5jZW9mIEVsZW1lbnRzKSAvLyBtb290b29sc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IGkgPSAwOyB2YXIgaiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZWQpIHtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldCBlbGVtZW50IHNpemVcclxuICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7d2lkdGgsIGhlaWdodH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2l6ZShlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChyZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IENTUyBzdHlsZXMgdG8gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGUpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIGZvciBkaW1lbnNpb24gY2hhbmdlIGRldGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfEVsZW1lbnRzfGpRdWVyeX0gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFJlc2l6ZVNlbnNvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKCkge1xyXG4gICAgICAgICAgICBsZXQgcSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBxLnB1c2goZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgbGV0IGk7IHZhciBqO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbihzaXplSW5mbykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcVtpXS5jYWxsKHRoaXMsIHNpemVJbmZvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwLCBqID0gcS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihxW2ldICE9PSBldikgbmV3UXVldWUucHVzaChxW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHEgPSBuZXdRdWV1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIHJlc2l6ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCByZXNpemVkKSB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5kaXIgPSAnbHRyJztcclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xyXG5cclxuICAgICAgICAgICAgbGV0IHN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMHB4JyxcclxuICAgICAgICAgICAgICAgIHRvcDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICByaWdodDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICBib3R0b206ICcwcHgnLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiAnLTEnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBzdHlsZUNoaWxkID0ge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMHB4JyxcclxuICAgICAgICAgICAgICAgIHRvcDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnMHMnLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2V0U3R5bGUoZWxlbWVudC5yZXNpemVTZW5zb3IsIHN0eWxlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBleHBhbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgZXhwYW5kLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yLWV4cGFuZCc7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKGV4cGFuZCwgc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGV4cGFuZENoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKGV4cGFuZENoaWxkLCBzdHlsZUNoaWxkKTtcclxuICAgICAgICAgICAgZXhwYW5kLmFwcGVuZENoaWxkKGV4cGFuZENoaWxkKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzaHJpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgc2hyaW5rLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yLXNocmluayc7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHNocmluaywgc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNocmlua0NoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHNocmlua0NoaWxkLCBzdHlsZUNoaWxkKTtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc2hyaW5rQ2hpbGQsIHsgd2lkdGg6ICcyMDAlJywgaGVpZ2h0OiAnMjAwJScgfSk7XHJcbiAgICAgICAgICAgIHNocmluay5hcHBlbmRDaGlsZChzaHJpbmtDaGlsZCk7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5hcHBlbmRDaGlsZChleHBhbmQpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5hcHBlbmRDaGlsZChzaHJpbmspO1xyXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQucmVzaXplU2Vuc29yKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZGlydHk7IHZhciByYWZJZDtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSBnZXRFbGVtZW50U2l6ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgbGV0IGxhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBsYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgbGV0IGluaXRpYWxIaWRkZW5DaGVjayA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBsYXN0QW5pbWF0aW9uRnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc2V0RXhwYW5kU2hyaW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9IGAke3dpZHRoICsgMTAgIH1weGA7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHQgKyAxMCAgfXB4YDtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IHdpZHRoICsgMTA7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gaGVpZ2h0ICsgMTA7XHJcblxyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgPSB3aWR0aCArIDEwO1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IGhlaWdodCArIDEwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaWRkZW5DaGVjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnZpc2libGUgPSBlbGVtZW50Lm9mZnNldFdpZHRoID09PSAwICYmIGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID09PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaW4gbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RBbmltYXRpb25GcmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QW5pbWF0aW9uRnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGNoZWNraW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxIaWRkZW5DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc2V0RXhwYW5kU2hyaW5rKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLnJlc2V0U2Vuc29yID0gcmVzZXQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgb25SZXNpemVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByYWZJZCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RXaWR0aCA9IHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBsYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuY2FsbChzaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxldCBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGdldEVsZW1lbnRTaXplKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZGlydHkgPSBzaXplLndpZHRoICE9PSBsYXN0V2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IGxhc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5ICYmICFyYWZJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uUmVzaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoYG9uJHsgIG5hbWV9YCwgY2IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50KGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcclxuICAgICAgICAgICAgYWRkRXZlbnQoc2hyaW5rLCAnc2Nyb2xsJywgb25TY3JvbGwpO1xyXG5cclxuICAgICAgICAgICAgLy8gRml4IGZvciBjdXN0b20gRWxlbWVudHNcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvckVhY2hFbGVtZW50KGVsZW1lbnQsIGZ1bmN0aW9uKGVsZW0pe1xyXG4gICAgICAgICAgICBhdHRhY2hSZXNpemVFdmVudChlbGVtLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50LCBldik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5yZXNldFNlbnNvcigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZVNlbnNvci5yZXNldCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcclxuICAgICAgICAgICAgZWxlbS5yZXNpemVTZW5zb3IucmVzZXRTZW5zb3IoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVzaXplU2Vuc29yLmRldGFjaCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2KSB7XHJcbiAgICAgICAgZm9yRWFjaEVsZW1lbnQoZWxlbWVudCwgZnVuY3Rpb24oZWxlbSl7XHJcbiAgICAgICAgICAgIGlmICghZWxlbSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihlbGVtLnJlc2l6ZWRBdHRhY2hlZCAmJiB0eXBlb2YgZXYgPT09IFwiZnVuY3Rpb25cIil7XHJcbiAgICAgICAgICAgICAgICBlbGVtLnJlc2l6ZWRBdHRhY2hlZC5yZW1vdmUoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYoZWxlbS5yZXNpemVkQXR0YWNoZWQubGVuZ3RoKCkpIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZWxlbS5yZXNpemVTZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNvbnRhaW5zKGVsZW0ucmVzaXplU2Vuc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2hpbGQoZWxlbS5yZXNpemVTZW5zb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplU2Vuc29yO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplZEF0dGFjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBtdXRhdGlvbnNbaV0uYWRkZWROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtc1tqXS5yZXNpemVTZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2l6ZVNlbnNvci5yZXNldChpdGVtc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlc2l6ZVNlbnNvcjtcclxuXHJcbn0pKTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/resizeSensor.js\n");

/***/ }),

/***/ "./components/sticky.js":
/*!******************************!*\
  !*** ./components/sticky.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sidebar = undefined;\n\n__webpack_require__(/*! ./resizeSensor */ \"./components/resizeSensor.js\");\n\n__webpack_require__(/*! sticky-sidebar */ \"../../node_modules/sticky-sidebar/src/sticky-sidebar.js\");\n\nvar sidebar = exports.sidebar = new StickySidebar('.js-sticky', {\n  topSpacing: 0,\n  responsiveWidth: true,\n  resizeSensor: true\n\n});\n\nvar stickyInterval;\nstickyInterval = setInterval(function () {\n  if (sidebar) {\n    sidebar.updateSticky();\n  }\n}, 500);\n\n// navigation podmenu\n$('.navigation-module ul li').each(function () {\n\n  if ($(this).find('ul').length) {\n\n    $(this).children('a').click(function (e) {\n      if (!$(this).parent().hasClass('active')) {\n        e.preventDefault();\n        // удалить у всех active\n        $('.navigation-module ul li ul').slideUp();\n        $('.navigation-module ul li').removeClass('active');\n        // добавить active\n        $(this).parent().find('ul').slideDown();\n        $(this).parent().toggleClass('active');\n        sidebar.updateSticky();\n      } else {\n        e.preventDefault();\n        $(this).parent().find('ul').slideUp();\n        $(this).parent().toggleClass('active');\n        sidebar.updateSticky();\n      }\n    });\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3N0aWNreS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9zdGlja3kuanM/ZDVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vcmVzaXplU2Vuc29yJztcclxuaW1wb3J0ICdzdGlja3ktc2lkZWJhcic7XHJcblxyXG5leHBvcnQgbGV0IHNpZGViYXIgPSBuZXcgU3RpY2t5U2lkZWJhcignLmpzLXN0aWNreScsIHtcclxuICB0b3BTcGFjaW5nOiAwLFxyXG4gIHJlc3BvbnNpdmVXaWR0aDogdHJ1ZSxcclxuICByZXNpemVTZW5zb3I6IHRydWUsXHJcblxyXG59KTtcclxuXHJcbnZhciBzdGlja3lJbnRlcnZhbDtcclxuc3RpY2t5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHNpZGViYXIpIHtcclxuICAgIHNpZGViYXIudXBkYXRlU3RpY2t5KCk7XHJcbiAgfVxyXG59LCA1MDApO1xyXG5cclxuLy8gbmF2aWdhdGlvbiBwb2RtZW51XHJcbiQoJy5uYXZpZ2F0aW9uLW1vZHVsZSB1bCBsaScpLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cclxuICBpZiAoJCh0aGlzKS5maW5kKCd1bCcpLmxlbmd0aCkge1xyXG5cclxuICAgICQodGhpcykuY2hpbGRyZW4oJ2EnKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoISQodGhpcykucGFyZW50KCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIC8vINGD0LTQsNC70LjRgtGMINGDINCy0YHQtdGFIGFjdGl2ZVxyXG4gICAgICAgICQoJy5uYXZpZ2F0aW9uLW1vZHVsZSB1bCBsaSB1bCcpLnNsaWRlVXAoKTtcclxuICAgICAgICAkKCcubmF2aWdhdGlvbi1tb2R1bGUgdWwgbGknKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgLy8g0LTQvtCx0LDQstC40YLRjCBhY3RpdmVcclxuICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoJ3VsJykuc2xpZGVEb3duKCk7XHJcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgc2lkZWJhci51cGRhdGVTdGlja3koKTtcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICQodGhpcykucGFyZW50KCkuZmluZCgndWwnKS5zbGlkZVVwKCk7XHJcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgc2lkZWJhci51cGRhdGVTdGlja3koKTtcclxuXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG59KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/sticky.js\n");

/***/ }),

/***/ "./lk.js":
/*!***************!*\
  !*** ./lk.js ***!
  \***************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\n__webpack_require__(/*! ./components/language-module */ \"./components/language-module.js\");\n\n__webpack_require__(/*! ./components/sticky */ \"./components/sticky.js\");\n\n// main\n$(document).ready(function () {\n    $('.loader').fadeOut();\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9say5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbGsuanM/OTI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vY29tcG9uZW50cy9sYW5ndWFnZS1tb2R1bGUnO1xyXG5pbXBvcnQgJy4vY29tcG9uZW50cy9zdGlja3knO1xyXG5cclxuLy8gbWFpblxyXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAkKCcubG9hZGVyJykuZmFkZU91dCgpO1xyXG59KTsiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lk.js\n");

/***/ })

/******/ });