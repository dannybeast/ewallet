/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"lk": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./lk.js","vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/sticky-sidebar/src/sticky-sidebar.js":
/*!******************************************************************************!*\
  !*** C:/Proj/html/ewallet/node_modules/sticky-sidebar/src/sticky-sidebar.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Sticky Sidebar JavaScript Plugin.\r\n * @version 3.3.1\r\n * @author Ahmed Bouhuolia <a.bouhuolia@gmail.com>\r\n * @license The MIT License (MIT)\r\n */\r\nconst StickySidebar = (() => {\r\n  \r\n    // ---------------------------------\r\n    // # Define Constants\r\n    // ---------------------------------\r\n    //\r\n    const EVENT_KEY = '.stickySidebar';\r\n    const VERSION   = '3.3.1';\r\n  \r\n    const DEFAULTS = {\r\n      \r\n      /**\r\n       * Additional top spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      topSpacing: 0,\r\n  \r\n      /**\r\n       * Additional bottom spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      bottomSpacing: 0,\r\n  \r\n      /**\r\n       * Container sidebar selector to know what the beginning and end of sticky element.\r\n       * @type {String|False}\r\n       */\r\n      containerSelector: false,\r\n  \r\n      /**\r\n       * Inner wrapper selector.\r\n       * @type {String}\r\n       */\r\n      innerWrapperSelector: '.inner-wrapper-sticky',\r\n  \r\n      /**\r\n       * The name of CSS class to apply to elements when they have become stuck.\r\n       * @type {String|False}\r\n       */\r\n      stickyClass: 'is-affixed',\r\n  \r\n      /**\r\n       * Detect when sidebar and its container change height so re-calculate their dimensions.\r\n       * @type {Boolean}\r\n       */\r\n      resizeSensor: true,\r\n  \r\n      /**\r\n       * The sidebar returns to its normal position if its width below this value.\r\n       * @type {Numeric}\r\n       */\r\n      minWidth: false\r\n    };\r\n  \r\n    // ---------------------------------\r\n    // # Class Definition\r\n    // ---------------------------------\r\n    //\r\n    /**\r\n     * Sticky Sidebar Class.\r\n     * @public\r\n     */\r\n    class StickySidebar{\r\n  \r\n      /**\r\n       * Sticky Sidebar Constructor.\r\n       * @constructor\r\n       * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\r\n       * @param {Object} options - The options of sticky sidebar.\r\n       */\r\n      constructor(sidebar, options = {}){\r\n        this.options = StickySidebar.extend(DEFAULTS, options);\r\n  \r\n        // Sidebar element query if there's no one, throw error.\r\n        this.sidebar = ('string' === typeof sidebar ) ? document.querySelector(sidebar) : sidebar;\r\n        if( 'undefined' === typeof this.sidebar )\r\n          throw new Error(\"There is no specific sidebar element.\");\r\n  \r\n        this.sidebarInner = false;\r\n        this.container = this.sidebar.parentElement;\r\n  \r\n        // Current Affix Type of sidebar element.\r\n        this.affixedType = 'STATIC';\r\n        this.direction = 'down';\r\n        this.support = {\r\n          transform:   false,\r\n          transform3d: false\r\n        };\r\n  \r\n        this._initialized = false;\r\n        this._reStyle = false;\r\n        this._breakpoint = false;\r\n        this._resizeListeners = [];\r\n        \r\n        // Dimensions of sidebar, container and screen viewport.\r\n        this.dimensions = {\r\n          translateY: 0,\r\n          topSpacing: 0,\r\n          lastTopSpacing: 0,\r\n          bottomSpacing: 0,\r\n          lastBottomSpacing: 0,\r\n          sidebarHeight: 0,\r\n          sidebarWidth: 0,\r\n          containerTop: 0,\r\n          containerHeight: 0,\r\n          viewportHeight: 0,\r\n          viewportTop: 0, \r\n          lastViewportTop: 0,\r\n        };\r\n  \r\n        // Bind event handlers for referencability.\r\n        ['handleEvent'].forEach( (method) => {\r\n          this[method] = this[method].bind(this);\r\n        });\r\n  \r\n        // Initialize sticky sidebar for first time.\r\n        this.initialize();\r\n      }\r\n  \r\n      /**\r\n       * Initializes the sticky sidebar by adding inner wrapper, define its container, \r\n       * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\r\n       * @private\r\n       */\r\n      initialize(){\r\n        this._setSupportFeatures();\r\n  \r\n        // Get sticky sidebar inner wrapper, if not found, will create one.\r\n        if( this.options.innerWrapperSelector ){\r\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\r\n  \r\n          if( null === this.sidebarInner )\r\n            this.sidebarInner = false;\r\n        }\r\n        \r\n        if( ! this.sidebarInner ){\r\n          let wrapper = document.createElement('div');\r\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\r\n          this.sidebar.appendChild(wrapper);\r\n  \r\n          while( this.sidebar.firstChild != wrapper )\r\n            wrapper.appendChild(this.sidebar.firstChild);\r\n  \r\n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\r\n        }\r\n  \r\n        // Container wrapper of the sidebar.\r\n        if( this.options.containerSelector ){\r\n          let containers = document.querySelectorAll(this.options.containerSelector);\r\n          containers = Array.prototype.slice.call(containers);\r\n  \r\n          containers.forEach((container, item) => {\r\n            if( ! container.contains(this.sidebar) ) return;\r\n            this.container = container;\r\n          });\r\n  \r\n          if( ! containers.length )\r\n            throw new Error(\"The container does not contains on the sidebar.\");\r\n        }\r\n        \r\n        // If top/bottom spacing is not function parse value to integer.\r\n        if( 'function' !== typeof this.options.topSpacing )\r\n          this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\r\n  \r\n        if( 'function' !== typeof this.options.bottomSpacing )\r\n          this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0;\r\n            \r\n        // Breakdown sticky sidebar if screen width below `options.minWidth`.\r\n        this._widthBreakpoint();\r\n  \r\n        // Calculate dimensions of sidebar, container and viewport.\r\n        this.calcDimensions();\r\n  \r\n        // Affix sidebar in proper position.\r\n        this.stickyPosition();\r\n  \r\n        // Bind all events.\r\n        this.bindEvents();\r\n        \r\n        // Inform other properties the sticky sidebar is initialized.\r\n        this._initialized = true;\r\n      }\r\n  \r\n      /**\r\n       * Bind all events of sticky sidebar plugin.\r\n       * @protected\r\n       */\r\n      bindEvents(){\r\n        window.addEventListener('resize', this, {passive: true, capture: false});\r\n        window.addEventListener('scroll', this, {passive: true, capture: false});\r\n  \r\n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\r\n          new ResizeSensor(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Handles all events of the plugin.\r\n       * @param {Object} event - Event object passed from listener.\r\n       */\r\n      handleEvent(event){\r\n        this.updateSticky(event);\r\n      }\r\n  \r\n      /**\r\n       * Calculates dimensions of sidebar, container and screen viewpoint\r\n       * @public\r\n       */\r\n      calcDimensions(){\r\n        if( this._breakpoint ) return;\r\n        var dims = this.dimensions;\r\n  \r\n        // Container of sticky sidebar dimensions.\r\n        dims.containerTop    = StickySidebar.offsetRelative(this.container).top;\r\n        dims.containerHeight = this.container.clientHeight;\r\n        dims.containerBottom = dims.containerTop + dims.containerHeight;\r\n  \r\n        // Sidebar dimensions.\r\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\r\n        dims.sidebarWidth  = this.sidebar.offsetWidth;\r\n        \r\n        // Screen viewport dimensions.\r\n        dims.viewportHeight = window.innerHeight;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n      }\r\n  \r\n      /**\r\n       * Some dimensions values need to be up-to-date when scrolling the page.\r\n       * @private\r\n       */\r\n      _calcDimensionsWithScroll(){\r\n        var dims = this.dimensions;\r\n  \r\n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\r\n  \r\n        dims.viewportTop    = document.documentElement.scrollTop || document.body.scrollTop;\r\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\r\n        dims.viewportLeft   = document.documentElement.scrollLeft || document.body.scrollLeft;\r\n  \r\n        dims.topSpacing    = this.options.topSpacing;\r\n        dims.bottomSpacing = this.options.bottomSpacing;\r\n  \r\n        if( 'function' === typeof dims.topSpacing )\r\n            dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\r\n  \r\n        if( 'function' === typeof dims.bottomSpacing )\r\n            dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\r\n        \r\n        if( 'VIEWPORT-TOP' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease top spacing value.\r\n          if( dims.topSpacing < dims.lastTopSpacing ){\r\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\r\n            this._reStyle = true; \r\n          }\r\n        \r\n        } else if( 'VIEWPORT-BOTTOM' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease bottom spacing value.\r\n          if( dims.bottomSpacing < dims.lastBottomSpacing ){\r\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\r\n            this._reStyle = true;\r\n          }\r\n        }\r\n        \r\n        dims.lastTopSpacing    = dims.topSpacing;\r\n        dims.lastBottomSpacing = dims.bottomSpacing;\r\n      }\r\n      \r\n      /**\r\n       * Determine whether the sidebar is bigger than viewport.\r\n       * @public\r\n       * @return {Boolean}\r\n       */\r\n      isSidebarFitsViewport(){\r\n        return this.dimensions.sidebarHeight < this.dimensions.viewportHeight;\r\n      }\r\n  \r\n      /**\r\n       * Observe browser scrolling direction top and down.\r\n       */\r\n      observeScrollDir(){\r\n        var dims = this.dimensions;\r\n        if( dims.lastViewportTop === dims.viewportTop ) return;\r\n  \r\n        var furthest = 'down' === this.direction ? Math.min : Math.max;\r\n        \r\n        // If the browser is scrolling not in the same direction.\r\n        if( dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop) )\r\n          this.direction = 'down' === this.direction ?  'up' : 'down';\r\n      }\r\n  \r\n      /**\r\n       * Gets affix type of sidebar according to current scrollTop and scrollLeft.\r\n       * Holds all logical affix of the sidebar when scrolling up and down and when sidebar \r\n       * is bigger than viewport and vice versa.\r\n       * @public\r\n       * @return {String|False} - Proper affix type.\r\n       */\r\n      getAffixType(){\r\n        var dims = this.dimensions, affixType = false;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n  \r\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\r\n        var colliderTop = dims.viewportTop + dims.topSpacing;\r\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\r\n  \r\n        // When browser is scrolling top.\r\n        if( 'up' === this.direction ){\r\n          if( colliderTop <= dims.containerTop ){\r\n            dims.translateY = 0;\r\n            affixType = 'STATIC';\r\n  \r\n          } else if( colliderTop <= dims.translateY + dims.containerTop ){\r\n            dims.translateY = colliderTop - dims.containerTop;\r\n            affixType = 'VIEWPORT-TOP';\r\n  \r\n          } else if( ! this.isSidebarFitsViewport() && dims.containerTop <= colliderTop ){\r\n            affixType = 'VIEWPORT-UNBOTTOM';\r\n          }\r\n        // When browser is scrolling up.\r\n        } else {\r\n          // When sidebar element is not bigger than screen viewport.\r\n          if( this.isSidebarFitsViewport() ){\r\n  \r\n            if( dims.sidebarHeight + colliderTop >= dims.containerBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom;\r\n              affixType = 'CONTAINER-BOTTOM'; \r\n  \r\n            } else if( colliderTop >= dims.containerTop ){\r\n              dims.translateY = colliderTop - dims.containerTop;\r\n              affixType = 'VIEWPORT-TOP';\r\n            }\r\n          // When sidebar element is bigger than screen viewport.\r\n          } else {\r\n      \r\n            if( dims.containerBottom <= colliderBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom; \r\n              affixType = 'CONTAINER-BOTTOM';    \r\n  \r\n            } else if( sidebarBottom + dims.translateY <= colliderBottom ){\r\n              dims.translateY = colliderBottom - sidebarBottom;\r\n              affixType = 'VIEWPORT-BOTTOM';\r\n            \r\n            } else if( dims.containerTop + dims.translateY <= colliderTop ){\r\n              affixType = 'VIEWPORT-UNBOTTOM';\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Make sure the translate Y is not bigger than container height.\r\n        dims.translateY = Math.max(0, dims.translateY);\r\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\r\n  \r\n        dims.lastViewportTop = dims.viewportTop;\r\n        return affixType;\r\n      }\r\n  \r\n      /**\r\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \r\n       * to its affix type.\r\n       * @private\r\n       * @param {String} affixType - Affix type of sticky sidebar.\r\n       * @return {Object}\r\n       */\r\n      _getStyle(affixType){\r\n        if( 'undefined' === typeof affixType ) return;\r\n  \r\n        var style = {inner: {}, outer: {}};\r\n        var dims = this.dimensions;\r\n  \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n            style.inner = {position: 'fixed', top: dims.topSpacing,\r\n                  left: dims.sidebarLeft - dims.viewportLeft, width: dims.sidebarWidth};\r\n            break;\r\n          case 'VIEWPORT-BOTTOM':\r\n            style.inner = {position: 'fixed', top: 'auto', left: dims.sidebarLeft,\r\n                  bottom: dims.bottomSpacing, width: dims.sidebarWidth};\r\n            break;\r\n          case 'CONTAINER-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n            let translate = this._getTranslate(0, dims.translateY + 'px');\r\n            \r\n            if( translate )\r\n              style.inner = {transform: translate};\r\n            else \r\n              style.inner = {position: 'absolute', top: dims.translateY, width: dims.sidebarWidth};\r\n            break;\r\n        }\r\n        \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n          case 'VIEWPORT-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n          case 'CONTAINER-BOTTOM':\r\n            style.outer = {height: dims.sidebarHeight, position: 'relative'};\r\n            break;\r\n        }\r\n  \r\n        style.outer = StickySidebar.extend({height: '', position: ''}, style.outer);\r\n        style.inner = StickySidebar.extend({position: 'relative', top: '', left: '',\r\n            bottom: '', width: '',  transform: this._getTranslate()}, style.inner);\r\n  \r\n        return style;\r\n      }\r\n     \r\n      /**\r\n       * Cause the sidebar to be sticky according to affix type by adding inline\r\n       * style, adding helper class and trigger events.\r\n       * @function\r\n       * @protected\r\n       * @param {string} force - Update sticky sidebar position by force.\r\n       */\r\n      stickyPosition(force){\r\n        if( this._breakpoint ) return;\r\n  \r\n        force = this._reStyle || force || false;\r\n        \r\n        var offsetTop = this.options.topSpacing;\r\n        var offsetBottom = this.options.bottomSpacing;\r\n  \r\n        var affixType = this.getAffixType();\r\n        var style = this._getStyle(affixType);\r\n        \r\n        if( (this.affixedType != affixType || force) && affixType ){\r\n          let affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\r\n  \r\n          if( 'STATIC' === affixType )\r\n            StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          else\r\n            StickySidebar.addClass(this.sidebar, this.options.stickyClass);\r\n          \r\n          for( let key in style.outer ){\r\n            let _unit = ('number' === typeof style.outer[key]) ? 'px' : '';\r\n            this.sidebar.style[key] = style.outer[key];\r\n          }\r\n  \r\n          for( let key in style.inner ){\r\n            let _unit = ('number' === typeof style.inner[key]) ? 'px' : '';\r\n            this.sidebarInner.style[key] = style.inner[key] + _unit;\r\n          }\r\n          \r\n          let affixedEvent = 'affixed.'+ affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\r\n        } else {\r\n          if( this._initialized ) this.sidebarInner.style.left = style.inner.left;\r\n        }\r\n  \r\n        this.affixedType = affixType;\r\n      }\r\n  \r\n      /**\r\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\r\n       * @protected\r\n       */\r\n      _widthBreakpoint(){\r\n  \r\n        if( window.innerWidth <= this.options.minWidth ){\r\n          this._breakpoint = true;\r\n          this.affixedType = 'STATIC';\r\n  \r\n          this.sidebar.removeAttribute('style');\r\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          this.sidebarInner.removeAttribute('style');\r\n        } else {\r\n          this._breakpoint = false;\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Switches between functions stack for each event type, if there's no \r\n       * event, it will re-initialize sticky sidebar.\r\n       * @public\r\n       */\r\n      updateSticky(event = {}){\r\n        if( this._running ) return;\r\n        this._running = true;\r\n  \r\n        ((eventType) => {\r\n\r\n          requestAnimationFrame(() => {\r\n            switch( eventType ){\r\n              // When browser is scrolling and re-calculate just dimensions\r\n              // within scroll. \r\n              case 'scroll':\r\n                this._calcDimensionsWithScroll();\r\n                this.observeScrollDir();\r\n                this.stickyPosition();\r\n                break;\r\n  \r\n              // When browser is resizing or there's no event, observe width\r\n              // breakpoint and re-calculate dimensions.\r\n              case 'resize':\r\n              default: \r\n                this._widthBreakpoint();\r\n                this.calcDimensions();\r\n                this.stickyPosition(true);\r\n                break;\r\n            }\r\n            this._running = false;\r\n          });\r\n        })(event.type);\r\n      }\r\n  \r\n      /**\r\n       * Set browser support features to the public property.\r\n       * @private\r\n       */\r\n      _setSupportFeatures(){\r\n        var support = this.support;\r\n  \r\n        support.transform = StickySidebar.supportTransform();\r\n        support.transform3d = StickySidebar.supportTransform(true);\r\n      }\r\n  \r\n      /**\r\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\r\n       * and the same with translate. if browser doesn't support both return false.\r\n       * @param {Number} y - Value of Y-axis.\r\n       * @param {Number} x - Value of X-axis.\r\n       * @param {Number} z - Value of Z-axis.\r\n       * @return {String|False}\r\n       */\r\n      _getTranslate(y = 0, x = 0, z = 0){\r\n        if( this.support.transform3d ) return 'translate3d(' + y +', '+ x +', '+ z +')';\r\n        else if( this.support.translate ) return 'translate('+ y +', '+ x +')';\r\n        else return false;\r\n      }\r\n  \r\n      /**\r\n       * Destroy sticky sidebar plugin.\r\n       * @public\r\n       */\r\n      destroy(){\r\n        window.removeEventListener('resize', this, {caption: false});\r\n        window.removeEventListener('scroll', this, {caption: false});\r\n  \r\n        this.sidebar.classList.remove(this.options.stickyClass);\r\n        this.sidebar.style.minHeight = '';\r\n  \r\n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\r\n  \r\n        var styleReset = {inner: {}, outer: {}};\r\n  \r\n        styleReset.inner = {position: '', top: '', left: '', bottom: '', width: '',  transform: ''};\r\n        styleReset.outer = {height: '', position: ''};\r\n  \r\n        for( let key in styleReset.outer )\r\n          this.sidebar.style[key] = styleReset.outer[key];\r\n  \r\n        for( let key in styleReset.inner )\r\n          this.sidebarInner.style[key] = styleReset.inner[key];\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\r\n          ResizeSensor.detach(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Determine if the browser supports CSS transform feature.\r\n       * @function\r\n       * @static\r\n       * @param {Boolean} transform3d - Detect transform with translate3d.\r\n       * @return {String}\r\n       */\r\n      static supportTransform(transform3d){\r\n        var result = false,\r\n            property = (transform3d) ? 'perspective' : 'transform',\r\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\r\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\r\n            support = document.createElement('support'),\r\n            style = support.style;\r\n  \r\n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function(property, i) {\r\n          if (style[property] !== undefined) {\r\n            result = property;\r\n            return false;\r\n          }\r\n        });\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Trigger custom event.\r\n       * @static\r\n       * @param {DOMObject} element - Target element on the DOM.\r\n       * @param {String} eventName - Event name.\r\n       * @param {Object} data - \r\n       */\r\n      static eventTrigger(element, eventName, data){\r\n        try{\r\n          var event = new CustomEvent(eventName, {detail: data});\r\n        } catch(e){\r\n          var event = document.createEvent('CustomEvent');\r\n          event.initCustomEvent(eventName, true, true, data);\r\n        }\r\n        element.dispatchEvent(event);\r\n      }\r\n  \r\n      /**\r\n       * Extend options object with defaults.\r\n       * @function\r\n       * @static\r\n       */\r\n      static extend(defaults, options){\r\n        var results = {};\r\n        for( let key in defaults ){\r\n          if( 'undefined' !== typeof options[key] ) results[key] = options[key];\r\n          else results[key] = defaults[key];\r\n        }\r\n        return results;\r\n      }\r\n  \r\n      /**\r\n       * Get current coordinates left and top of specific element.\r\n       * @static\r\n       */\r\n      static offsetRelative(element){\r\n        var result = {left: 0, top: 0};\r\n\r\n        do{\r\n          let offsetTop = element.offsetTop;\r\n          let offsetLeft = element.offsetLeft;\r\n  \r\n          if( ! isNaN(offsetTop) )\r\n            result.top += offsetTop;\r\n  \r\n          if( ! isNaN(offsetLeft) )\r\n            result.left += offsetLeft;\r\n\r\n          element = ( 'BODY' === element.tagName ) ?\r\n                      element.parentElement : element.offsetParent;\r\n        } while(element)\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Add specific class name to specific element.\r\n       * @static \r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static addClass(element, className){\r\n        if( ! StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.add(className);\r\n          else\r\n            element.className += ' ' + className;\r\n        }\r\n      }\r\n      \r\n      /**\r\n       * Remove specific class name to specific element\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static removeClass(element, className){\r\n        if( StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.remove(className);\r\n          else\r\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Determine weather the element has specific class name.\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static hasClass(element, className){\r\n        if (element.classList)\r\n          return element.classList.contains(className);\r\n        else\r\n          return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\r\n      }\r\n    }\r\n  \r\n    return StickySidebar;\r\n  })();\r\n  \r\n  /* harmony default export */ __webpack_exports__[\"default\"] = (StickySidebar);\r\n  \r\n  // Global\r\n  // -------------------------\r\n  window.StickySidebar = StickySidebar;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3N0aWNreS1zaWRlYmFyL3NyYy9zdGlja3ktc2lkZWJhci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9DOi9Qcm9qL2h0bWwvZXdhbGxldC9ub2RlX21vZHVsZXMvc3RpY2t5LXNpZGViYXIvc3JjL3N0aWNreS1zaWRlYmFyLmpzPzRiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFN0aWNreSBTaWRlYmFyIEphdmFTY3JpcHQgUGx1Z2luLlxyXG4gKiBAdmVyc2lvbiAzLjMuMVxyXG4gKiBAYXV0aG9yIEFobWVkIEJvdWh1b2xpYSA8YS5ib3VodW9saWFAZ21haWwuY29tPlxyXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICovXHJcbmNvbnN0IFN0aWNreVNpZGViYXIgPSAoKCkgPT4ge1xyXG4gIFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyAjIERlZmluZSBDb25zdGFudHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy9cclxuICAgIGNvbnN0IEVWRU5UX0tFWSA9ICcuc3RpY2t5U2lkZWJhcic7XHJcbiAgICBjb25zdCBWRVJTSU9OICAgPSAnMy4zLjEnO1xyXG4gIFxyXG4gICAgY29uc3QgREVGQVVMVFMgPSB7XHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuICAgICAgICogQWRkaXRpb25hbCB0b3Agc3BhY2luZyBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxyXG4gICAgICAgKiBAdHlwZSB7TnVtZXJpY3xGdW5jdGlvbn1cclxuICAgICAgICovXHJcbiAgICAgIHRvcFNwYWNpbmc6IDAsXHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBZGRpdGlvbmFsIGJvdHRvbSBzcGFjaW5nIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXHJcbiAgICAgICAqIEB0eXBlIHtOdW1lcmljfEZ1bmN0aW9ufVxyXG4gICAgICAgKi9cclxuICAgICAgYm90dG9tU3BhY2luZzogMCxcclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIENvbnRhaW5lciBzaWRlYmFyIHNlbGVjdG9yIHRvIGtub3cgd2hhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2Ygc3RpY2t5IGVsZW1lbnQuXHJcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd8RmFsc2V9XHJcbiAgICAgICAqL1xyXG4gICAgICBjb250YWluZXJTZWxlY3RvcjogZmFsc2UsXHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBJbm5lciB3cmFwcGVyIHNlbGVjdG9yLlxyXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICAgKi9cclxuICAgICAgaW5uZXJXcmFwcGVyU2VsZWN0b3I6ICcuaW5uZXItd3JhcHBlci1zdGlja3knLFxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIG5hbWUgb2YgQ1NTIGNsYXNzIHRvIGFwcGx5IHRvIGVsZW1lbnRzIHdoZW4gdGhleSBoYXZlIGJlY29tZSBzdHVjay5cclxuICAgICAgICogQHR5cGUge1N0cmluZ3xGYWxzZX1cclxuICAgICAgICovXHJcbiAgICAgIHN0aWNreUNsYXNzOiAnaXMtYWZmaXhlZCcsXHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXRlY3Qgd2hlbiBzaWRlYmFyIGFuZCBpdHMgY29udGFpbmVyIGNoYW5nZSBoZWlnaHQgc28gcmUtY2FsY3VsYXRlIHRoZWlyIGRpbWVuc2lvbnMuXHJcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICAgKi9cclxuICAgICAgcmVzaXplU2Vuc29yOiB0cnVlLFxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogVGhlIHNpZGViYXIgcmV0dXJucyB0byBpdHMgbm9ybWFsIHBvc2l0aW9uIGlmIGl0cyB3aWR0aCBiZWxvdyB0aGlzIHZhbHVlLlxyXG4gICAgICAgKiBAdHlwZSB7TnVtZXJpY31cclxuICAgICAgICovXHJcbiAgICAgIG1pbldpZHRoOiBmYWxzZVxyXG4gICAgfTtcclxuICBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gIyBDbGFzcyBEZWZpbml0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vXHJcbiAgICAvKipcclxuICAgICAqIFN0aWNreSBTaWRlYmFyIENsYXNzLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBjbGFzcyBTdGlja3lTaWRlYmFye1xyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogU3RpY2t5IFNpZGViYXIgQ29uc3RydWN0b3IuXHJcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gc2lkZWJhciAtIFRoZSBzaWRlYmFyIGVsZW1lbnQgb3Igc2lkZWJhciBzZWxlY3Rvci5cclxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiBzdGlja3kgc2lkZWJhci5cclxuICAgICAgICovXHJcbiAgICAgIGNvbnN0cnVjdG9yKHNpZGViYXIsIG9wdGlvbnMgPSB7fSl7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gU3RpY2t5U2lkZWJhci5leHRlbmQoREVGQVVMVFMsIG9wdGlvbnMpO1xyXG4gIFxyXG4gICAgICAgIC8vIFNpZGViYXIgZWxlbWVudCBxdWVyeSBpZiB0aGVyZSdzIG5vIG9uZSwgdGhyb3cgZXJyb3IuXHJcbiAgICAgICAgdGhpcy5zaWRlYmFyID0gKCdzdHJpbmcnID09PSB0eXBlb2Ygc2lkZWJhciApID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaWRlYmFyKSA6IHNpZGViYXI7XHJcbiAgICAgICAgaWYoICd1bmRlZmluZWQnID09PSB0eXBlb2YgdGhpcy5zaWRlYmFyIClcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHNwZWNpZmljIHNpZGViYXIgZWxlbWVudC5cIik7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuc2lkZWJhci5wYXJlbnRFbGVtZW50O1xyXG4gIFxyXG4gICAgICAgIC8vIEN1cnJlbnQgQWZmaXggVHlwZSBvZiBzaWRlYmFyIGVsZW1lbnQuXHJcbiAgICAgICAgdGhpcy5hZmZpeGVkVHlwZSA9ICdTVEFUSUMnO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2Rvd24nO1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHtcclxuICAgICAgICAgIHRyYW5zZm9ybTogICBmYWxzZSxcclxuICAgICAgICAgIHRyYW5zZm9ybTNkOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgXHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZVN0eWxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYnJlYWtwb2ludCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERpbWVuc2lvbnMgb2Ygc2lkZWJhciwgY29udGFpbmVyIGFuZCBzY3JlZW4gdmlld3BvcnQuXHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zID0ge1xyXG4gICAgICAgICAgdHJhbnNsYXRlWTogMCxcclxuICAgICAgICAgIHRvcFNwYWNpbmc6IDAsXHJcbiAgICAgICAgICBsYXN0VG9wU3BhY2luZzogMCxcclxuICAgICAgICAgIGJvdHRvbVNwYWNpbmc6IDAsXHJcbiAgICAgICAgICBsYXN0Qm90dG9tU3BhY2luZzogMCxcclxuICAgICAgICAgIHNpZGViYXJIZWlnaHQ6IDAsXHJcbiAgICAgICAgICBzaWRlYmFyV2lkdGg6IDAsXHJcbiAgICAgICAgICBjb250YWluZXJUb3A6IDAsXHJcbiAgICAgICAgICBjb250YWluZXJIZWlnaHQ6IDAsXHJcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodDogMCxcclxuICAgICAgICAgIHZpZXdwb3J0VG9wOiAwLCBcclxuICAgICAgICAgIGxhc3RWaWV3cG9ydFRvcDogMCxcclxuICAgICAgICB9O1xyXG4gIFxyXG4gICAgICAgIC8vIEJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIHJlZmVyZW5jYWJpbGl0eS5cclxuICAgICAgICBbJ2hhbmRsZUV2ZW50J10uZm9yRWFjaCggKG1ldGhvZCkgPT4ge1xyXG4gICAgICAgICAgdGhpc1ttZXRob2RdID0gdGhpc1ttZXRob2RdLmJpbmQodGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdGlja3kgc2lkZWJhciBmb3IgZmlyc3QgdGltZS5cclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBzaWRlYmFyIGJ5IGFkZGluZyBpbm5lciB3cmFwcGVyLCBkZWZpbmUgaXRzIGNvbnRhaW5lciwgXHJcbiAgICAgICAqIG1pbi13aWR0aCBicmVha3BvaW50LCBjYWxjdWxhdGluZyBkaW1lbnNpb25zLCBhZGRpbmcgaGVscGVyIGNsYXNzZXMgYW5kIGlubGluZSBzdHlsZS5cclxuICAgICAgICogQHByaXZhdGVcclxuICAgICAgICovXHJcbiAgICAgIGluaXRpYWxpemUoKXtcclxuICAgICAgICB0aGlzLl9zZXRTdXBwb3J0RmVhdHVyZXMoKTtcclxuICBcclxuICAgICAgICAvLyBHZXQgc3RpY2t5IHNpZGViYXIgaW5uZXIgd3JhcHBlciwgaWYgbm90IGZvdW5kLCB3aWxsIGNyZWF0ZSBvbmUuXHJcbiAgICAgICAgaWYoIHRoaXMub3B0aW9ucy5pbm5lcldyYXBwZXJTZWxlY3RvciApe1xyXG4gICAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIgPSB0aGlzLnNpZGViYXIucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuaW5uZXJXcmFwcGVyU2VsZWN0b3IpO1xyXG4gIFxyXG4gICAgICAgICAgaWYoIG51bGwgPT09IHRoaXMuc2lkZWJhcklubmVyIClcclxuICAgICAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoICEgdGhpcy5zaWRlYmFySW5uZXIgKXtcclxuICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnaW5uZXItd3JhcHBlci1zdGlja3knKTtcclxuICAgICAgICAgIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcclxuICBcclxuICAgICAgICAgIHdoaWxlKCB0aGlzLnNpZGViYXIuZmlyc3RDaGlsZCAhPSB3cmFwcGVyIClcclxuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnNpZGViYXIuZmlyc3RDaGlsZCk7XHJcbiAgXHJcbiAgICAgICAgICB0aGlzLnNpZGViYXJJbm5lciA9IHRoaXMuc2lkZWJhci5xdWVyeVNlbGVjdG9yKCcuaW5uZXItd3JhcHBlci1zdGlja3knKTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgLy8gQ29udGFpbmVyIHdyYXBwZXIgb2YgdGhlIHNpZGViYXIuXHJcbiAgICAgICAgaWYoIHRoaXMub3B0aW9ucy5jb250YWluZXJTZWxlY3RvciApe1xyXG4gICAgICAgICAgbGV0IGNvbnRhaW5lcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5jb250YWluZXJTZWxlY3Rvcik7XHJcbiAgICAgICAgICBjb250YWluZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVycyk7XHJcbiAgXHJcbiAgICAgICAgICBjb250YWluZXJzLmZvckVhY2goKGNvbnRhaW5lciwgaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBpZiggISBjb250YWluZXIuY29udGFpbnModGhpcy5zaWRlYmFyKSApIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgICB9KTtcclxuICBcclxuICAgICAgICAgIGlmKCAhIGNvbnRhaW5lcnMubGVuZ3RoIClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnRhaW5lciBkb2VzIG5vdCBjb250YWlucyBvbiB0aGUgc2lkZWJhci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIHRvcC9ib3R0b20gc3BhY2luZyBpcyBub3QgZnVuY3Rpb24gcGFyc2UgdmFsdWUgdG8gaW50ZWdlci5cclxuICAgICAgICBpZiggJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHRoaXMub3B0aW9ucy50b3BTcGFjaW5nIClcclxuICAgICAgICAgIHRoaXMub3B0aW9ucy50b3BTcGFjaW5nID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnRvcFNwYWNpbmcpIHx8IDA7XHJcbiAgXHJcbiAgICAgICAgaWYoICdmdW5jdGlvbicgIT09IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZyApXHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZyA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nKSB8fCAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAvLyBCcmVha2Rvd24gc3RpY2t5IHNpZGViYXIgaWYgc2NyZWVuIHdpZHRoIGJlbG93IGBvcHRpb25zLm1pbldpZHRoYC5cclxuICAgICAgICB0aGlzLl93aWR0aEJyZWFrcG9pbnQoKTtcclxuICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgZGltZW5zaW9ucyBvZiBzaWRlYmFyLCBjb250YWluZXIgYW5kIHZpZXdwb3J0LlxyXG4gICAgICAgIHRoaXMuY2FsY0RpbWVuc2lvbnMoKTtcclxuICBcclxuICAgICAgICAvLyBBZmZpeCBzaWRlYmFyIGluIHByb3BlciBwb3NpdGlvbi5cclxuICAgICAgICB0aGlzLnN0aWNreVBvc2l0aW9uKCk7XHJcbiAgXHJcbiAgICAgICAgLy8gQmluZCBhbGwgZXZlbnRzLlxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEluZm9ybSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBzdGlja3kgc2lkZWJhciBpcyBpbml0aWFsaXplZC5cclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEJpbmQgYWxsIGV2ZW50cyBvZiBzdGlja3kgc2lkZWJhciBwbHVnaW4uXHJcbiAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICovXHJcbiAgICAgIGJpbmRFdmVudHMoKXtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcywge3Bhc3NpdmU6IHRydWUsIGNhcHR1cmU6IGZhbHNlfSk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMsIHtwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiBmYWxzZX0pO1xyXG4gIFxyXG4gICAgICAgIHRoaXMuc2lkZWJhci5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGUnICsgRVZFTlRfS0VZLCB0aGlzKTtcclxuICBcclxuICAgICAgICBpZiggdGhpcy5vcHRpb25zLnJlc2l6ZVNlbnNvciAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIFJlc2l6ZVNlbnNvciApe1xyXG4gICAgICAgICAgbmV3IFJlc2l6ZVNlbnNvcih0aGlzLnNpZGViYXJJbm5lciwgdGhpcy5oYW5kbGVFdmVudCk7XHJcbiAgICAgICAgICBuZXcgUmVzaXplU2Vuc29yKHRoaXMuY29udGFpbmVyLCB0aGlzLmhhbmRsZUV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEhhbmRsZXMgYWxsIGV2ZW50cyBvZiB0aGUgcGx1Z2luLlxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXHJcbiAgICAgICAqL1xyXG4gICAgICBoYW5kbGVFdmVudChldmVudCl7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTdGlja3koZXZlbnQpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBDYWxjdWxhdGVzIGRpbWVuc2lvbnMgb2Ygc2lkZWJhciwgY29udGFpbmVyIGFuZCBzY3JlZW4gdmlld3BvaW50XHJcbiAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICovXHJcbiAgICAgIGNhbGNEaW1lbnNpb25zKCl7XHJcbiAgICAgICAgaWYoIHRoaXMuX2JyZWFrcG9pbnQgKSByZXR1cm47XHJcbiAgICAgICAgdmFyIGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XHJcbiAgXHJcbiAgICAgICAgLy8gQ29udGFpbmVyIG9mIHN0aWNreSBzaWRlYmFyIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgZGltcy5jb250YWluZXJUb3AgICAgPSBTdGlja3lTaWRlYmFyLm9mZnNldFJlbGF0aXZlKHRoaXMuY29udGFpbmVyKS50b3A7XHJcbiAgICAgICAgZGltcy5jb250YWluZXJIZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgZGltcy5jb250YWluZXJCb3R0b20gPSBkaW1zLmNvbnRhaW5lclRvcCArIGRpbXMuY29udGFpbmVySGVpZ2h0O1xyXG4gIFxyXG4gICAgICAgIC8vIFNpZGViYXIgZGltZW5zaW9ucy5cclxuICAgICAgICBkaW1zLnNpZGViYXJIZWlnaHQgPSB0aGlzLnNpZGViYXJJbm5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgZGltcy5zaWRlYmFyV2lkdGggID0gdGhpcy5zaWRlYmFyLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNjcmVlbiB2aWV3cG9ydCBkaW1lbnNpb25zLlxyXG4gICAgICAgIGRpbXMudmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgXHJcbiAgICAgICAgdGhpcy5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNvbWUgZGltZW5zaW9ucyB2YWx1ZXMgbmVlZCB0byBiZSB1cC10by1kYXRlIHdoZW4gc2Nyb2xsaW5nIHRoZSBwYWdlLlxyXG4gICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgKi9cclxuICAgICAgX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpe1xyXG4gICAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1lbnNpb25zO1xyXG4gIFxyXG4gICAgICAgIGRpbXMuc2lkZWJhckxlZnQgPSBTdGlja3lTaWRlYmFyLm9mZnNldFJlbGF0aXZlKHRoaXMuc2lkZWJhcikubGVmdDtcclxuICBcclxuICAgICAgICBkaW1zLnZpZXdwb3J0VG9wICAgID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcclxuICAgICAgICBkaW1zLnZpZXdwb3J0Qm90dG9tID0gZGltcy52aWV3cG9ydFRvcCArIGRpbXMudmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgICAgZGltcy52aWV3cG9ydExlZnQgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcclxuICBcclxuICAgICAgICBkaW1zLnRvcFNwYWNpbmcgICAgPSB0aGlzLm9wdGlvbnMudG9wU3BhY2luZztcclxuICAgICAgICBkaW1zLmJvdHRvbVNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZztcclxuICBcclxuICAgICAgICBpZiggJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRpbXMudG9wU3BhY2luZyApXHJcbiAgICAgICAgICAgIGRpbXMudG9wU3BhY2luZyA9IHBhcnNlSW50KGRpbXMudG9wU3BhY2luZyh0aGlzLnNpZGViYXIpKSB8fCAwO1xyXG4gIFxyXG4gICAgICAgIGlmKCAnZnVuY3Rpb24nID09PSB0eXBlb2YgZGltcy5ib3R0b21TcGFjaW5nIClcclxuICAgICAgICAgICAgZGltcy5ib3R0b21TcGFjaW5nID0gcGFyc2VJbnQoZGltcy5ib3R0b21TcGFjaW5nKHRoaXMuc2lkZWJhcikpIHx8IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoICdWSUVXUE9SVC1UT1AnID09PSB0aGlzLmFmZml4ZWRUeXBlICl7XHJcbiAgICAgICAgICAvLyBBZGp1c3QgdHJhbnNsYXRlIFkgaW4gdGhlIGNhc2UgZGVjcmVhc2UgdG9wIHNwYWNpbmcgdmFsdWUuXHJcbiAgICAgICAgICBpZiggZGltcy50b3BTcGFjaW5nIDwgZGltcy5sYXN0VG9wU3BhY2luZyApe1xyXG4gICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgKz0gZGltcy5sYXN0VG9wU3BhY2luZyAtIGRpbXMudG9wU3BhY2luZztcclxuICAgICAgICAgICAgdGhpcy5fcmVTdHlsZSA9IHRydWU7IFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIH0gZWxzZSBpZiggJ1ZJRVdQT1JULUJPVFRPTScgPT09IHRoaXMuYWZmaXhlZFR5cGUgKXtcclxuICAgICAgICAgIC8vIEFkanVzdCB0cmFuc2xhdGUgWSBpbiB0aGUgY2FzZSBkZWNyZWFzZSBib3R0b20gc3BhY2luZyB2YWx1ZS5cclxuICAgICAgICAgIGlmKCBkaW1zLmJvdHRvbVNwYWNpbmcgPCBkaW1zLmxhc3RCb3R0b21TcGFjaW5nICl7XHJcbiAgICAgICAgICAgIGRpbXMudHJhbnNsYXRlWSArPSBkaW1zLmxhc3RCb3R0b21TcGFjaW5nIC0gZGltcy5ib3R0b21TcGFjaW5nO1xyXG4gICAgICAgICAgICB0aGlzLl9yZVN0eWxlID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZGltcy5sYXN0VG9wU3BhY2luZyAgICA9IGRpbXMudG9wU3BhY2luZztcclxuICAgICAgICBkaW1zLmxhc3RCb3R0b21TcGFjaW5nID0gZGltcy5ib3R0b21TcGFjaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuICAgICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNpZGViYXIgaXMgYmlnZ2VyIHRoYW4gdmlld3BvcnQuXHJcbiAgICAgICAqIEBwdWJsaWNcclxuICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICovXHJcbiAgICAgIGlzU2lkZWJhckZpdHNWaWV3cG9ydCgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMuc2lkZWJhckhlaWdodCA8IHRoaXMuZGltZW5zaW9ucy52aWV3cG9ydEhlaWdodDtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogT2JzZXJ2ZSBicm93c2VyIHNjcm9sbGluZyBkaXJlY3Rpb24gdG9wIGFuZCBkb3duLlxyXG4gICAgICAgKi9cclxuICAgICAgb2JzZXJ2ZVNjcm9sbERpcigpe1xyXG4gICAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1lbnNpb25zO1xyXG4gICAgICAgIGlmKCBkaW1zLmxhc3RWaWV3cG9ydFRvcCA9PT0gZGltcy52aWV3cG9ydFRvcCApIHJldHVybjtcclxuICBcclxuICAgICAgICB2YXIgZnVydGhlc3QgPSAnZG93bicgPT09IHRoaXMuZGlyZWN0aW9uID8gTWF0aC5taW4gOiBNYXRoLm1heDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiB0aGUgYnJvd3NlciBpcyBzY3JvbGxpbmcgbm90IGluIHRoZSBzYW1lIGRpcmVjdGlvbi5cclxuICAgICAgICBpZiggZGltcy52aWV3cG9ydFRvcCA9PT0gZnVydGhlc3QoZGltcy52aWV3cG9ydFRvcCwgZGltcy5sYXN0Vmlld3BvcnRUb3ApIClcclxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2Rvd24nID09PSB0aGlzLmRpcmVjdGlvbiA/ICAndXAnIDogJ2Rvd24nO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXRzIGFmZml4IHR5cGUgb2Ygc2lkZWJhciBhY2NvcmRpbmcgdG8gY3VycmVudCBzY3JvbGxUb3AgYW5kIHNjcm9sbExlZnQuXHJcbiAgICAgICAqIEhvbGRzIGFsbCBsb2dpY2FsIGFmZml4IG9mIHRoZSBzaWRlYmFyIHdoZW4gc2Nyb2xsaW5nIHVwIGFuZCBkb3duIGFuZCB3aGVuIHNpZGViYXIgXHJcbiAgICAgICAqIGlzIGJpZ2dlciB0aGFuIHZpZXdwb3J0IGFuZCB2aWNlIHZlcnNhLlxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqIEByZXR1cm4ge1N0cmluZ3xGYWxzZX0gLSBQcm9wZXIgYWZmaXggdHlwZS5cclxuICAgICAgICovXHJcbiAgICAgIGdldEFmZml4VHlwZSgpe1xyXG4gICAgICAgIHZhciBkaW1zID0gdGhpcy5kaW1lbnNpb25zLCBhZmZpeFR5cGUgPSBmYWxzZTtcclxuICBcclxuICAgICAgICB0aGlzLl9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGwoKTtcclxuICBcclxuICAgICAgICB2YXIgc2lkZWJhckJvdHRvbSA9IGRpbXMuc2lkZWJhckhlaWdodCArIGRpbXMuY29udGFpbmVyVG9wO1xyXG4gICAgICAgIHZhciBjb2xsaWRlclRvcCA9IGRpbXMudmlld3BvcnRUb3AgKyBkaW1zLnRvcFNwYWNpbmc7XHJcbiAgICAgICAgdmFyIGNvbGxpZGVyQm90dG9tID0gZGltcy52aWV3cG9ydEJvdHRvbSAtIGRpbXMuYm90dG9tU3BhY2luZztcclxuICBcclxuICAgICAgICAvLyBXaGVuIGJyb3dzZXIgaXMgc2Nyb2xsaW5nIHRvcC5cclxuICAgICAgICBpZiggJ3VwJyA9PT0gdGhpcy5kaXJlY3Rpb24gKXtcclxuICAgICAgICAgIGlmKCBjb2xsaWRlclRvcCA8PSBkaW1zLmNvbnRhaW5lclRvcCApe1xyXG4gICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSAwO1xyXG4gICAgICAgICAgICBhZmZpeFR5cGUgPSAnU1RBVElDJztcclxuICBcclxuICAgICAgICAgIH0gZWxzZSBpZiggY29sbGlkZXJUb3AgPD0gZGltcy50cmFuc2xhdGVZICsgZGltcy5jb250YWluZXJUb3AgKXtcclxuICAgICAgICAgICAgZGltcy50cmFuc2xhdGVZID0gY29sbGlkZXJUb3AgLSBkaW1zLmNvbnRhaW5lclRvcDtcclxuICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1ZJRVdQT1JULVRPUCc7XHJcbiAgXHJcbiAgICAgICAgICB9IGVsc2UgaWYoICEgdGhpcy5pc1NpZGViYXJGaXRzVmlld3BvcnQoKSAmJiBkaW1zLmNvbnRhaW5lclRvcCA8PSBjb2xsaWRlclRvcCApe1xyXG4gICAgICAgICAgICBhZmZpeFR5cGUgPSAnVklFV1BPUlQtVU5CT1RUT00nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIC8vIFdoZW4gYnJvd3NlciBpcyBzY3JvbGxpbmcgdXAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIFdoZW4gc2lkZWJhciBlbGVtZW50IGlzIG5vdCBiaWdnZXIgdGhhbiBzY3JlZW4gdmlld3BvcnQuXHJcbiAgICAgICAgICBpZiggdGhpcy5pc1NpZGViYXJGaXRzVmlld3BvcnQoKSApe1xyXG4gIFxyXG4gICAgICAgICAgICBpZiggZGltcy5zaWRlYmFySGVpZ2h0ICsgY29sbGlkZXJUb3AgPj0gZGltcy5jb250YWluZXJCb3R0b20gKXtcclxuICAgICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSBkaW1zLmNvbnRhaW5lckJvdHRvbSAtIHNpZGViYXJCb3R0b207XHJcbiAgICAgICAgICAgICAgYWZmaXhUeXBlID0gJ0NPTlRBSU5FUi1CT1RUT00nOyBcclxuICBcclxuICAgICAgICAgICAgfSBlbHNlIGlmKCBjb2xsaWRlclRvcCA+PSBkaW1zLmNvbnRhaW5lclRvcCApe1xyXG4gICAgICAgICAgICAgIGRpbXMudHJhbnNsYXRlWSA9IGNvbGxpZGVyVG9wIC0gZGltcy5jb250YWluZXJUb3A7XHJcbiAgICAgICAgICAgICAgYWZmaXhUeXBlID0gJ1ZJRVdQT1JULVRPUCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFdoZW4gc2lkZWJhciBlbGVtZW50IGlzIGJpZ2dlciB0aGFuIHNjcmVlbiB2aWV3cG9ydC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgIFxyXG4gICAgICAgICAgICBpZiggZGltcy5jb250YWluZXJCb3R0b20gPD0gY29sbGlkZXJCb3R0b20gKXtcclxuICAgICAgICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSBkaW1zLmNvbnRhaW5lckJvdHRvbSAtIHNpZGViYXJCb3R0b207IFxyXG4gICAgICAgICAgICAgIGFmZml4VHlwZSA9ICdDT05UQUlORVItQk9UVE9NJzsgICAgXHJcbiAgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggc2lkZWJhckJvdHRvbSArIGRpbXMudHJhbnNsYXRlWSA8PSBjb2xsaWRlckJvdHRvbSApe1xyXG4gICAgICAgICAgICAgIGRpbXMudHJhbnNsYXRlWSA9IGNvbGxpZGVyQm90dG9tIC0gc2lkZWJhckJvdHRvbTtcclxuICAgICAgICAgICAgICBhZmZpeFR5cGUgPSAnVklFV1BPUlQtQk9UVE9NJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiggZGltcy5jb250YWluZXJUb3AgKyBkaW1zLnRyYW5zbGF0ZVkgPD0gY29sbGlkZXJUb3AgKXtcclxuICAgICAgICAgICAgICBhZmZpeFR5cGUgPSAnVklFV1BPUlQtVU5CT1RUT00nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdHJhbnNsYXRlIFkgaXMgbm90IGJpZ2dlciB0aGFuIGNvbnRhaW5lciBoZWlnaHQuXHJcbiAgICAgICAgZGltcy50cmFuc2xhdGVZID0gTWF0aC5tYXgoMCwgZGltcy50cmFuc2xhdGVZKTtcclxuICAgICAgICBkaW1zLnRyYW5zbGF0ZVkgPSBNYXRoLm1pbihkaW1zLmNvbnRhaW5lckhlaWdodCwgZGltcy50cmFuc2xhdGVZKTtcclxuICBcclxuICAgICAgICBkaW1zLmxhc3RWaWV3cG9ydFRvcCA9IGRpbXMudmlld3BvcnRUb3A7XHJcbiAgICAgICAgcmV0dXJuIGFmZml4VHlwZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0cyBpbmxpbmUgc3R5bGUgb2Ygc3RpY2t5IHNpZGViYXIgd3JhcHBlciBhbmQgaW5uZXIgd3JhcHBlciBhY2NvcmRpbmcgXHJcbiAgICAgICAqIHRvIGl0cyBhZmZpeCB0eXBlLlxyXG4gICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWZmaXhUeXBlIC0gQWZmaXggdHlwZSBvZiBzdGlja3kgc2lkZWJhci5cclxuICAgICAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAgICAgKi9cclxuICAgICAgX2dldFN0eWxlKGFmZml4VHlwZSl7XHJcbiAgICAgICAgaWYoICd1bmRlZmluZWQnID09PSB0eXBlb2YgYWZmaXhUeXBlICkgcmV0dXJuO1xyXG4gIFxyXG4gICAgICAgIHZhciBzdHlsZSA9IHtpbm5lcjoge30sIG91dGVyOiB7fX07XHJcbiAgICAgICAgdmFyIGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XHJcbiAgXHJcbiAgICAgICAgc3dpdGNoKCBhZmZpeFR5cGUgKXtcclxuICAgICAgICAgIGNhc2UgJ1ZJRVdQT1JULVRPUCc6XHJcbiAgICAgICAgICAgIHN0eWxlLmlubmVyID0ge3Bvc2l0aW9uOiAnZml4ZWQnLCB0b3A6IGRpbXMudG9wU3BhY2luZyxcclxuICAgICAgICAgICAgICAgICAgbGVmdDogZGltcy5zaWRlYmFyTGVmdCAtIGRpbXMudmlld3BvcnRMZWZ0LCB3aWR0aDogZGltcy5zaWRlYmFyV2lkdGh9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1ZJRVdQT1JULUJPVFRPTSc6XHJcbiAgICAgICAgICAgIHN0eWxlLmlubmVyID0ge3Bvc2l0aW9uOiAnZml4ZWQnLCB0b3A6ICdhdXRvJywgbGVmdDogZGltcy5zaWRlYmFyTGVmdCxcclxuICAgICAgICAgICAgICAgICAgYm90dG9tOiBkaW1zLmJvdHRvbVNwYWNpbmcsIHdpZHRoOiBkaW1zLnNpZGViYXJXaWR0aH07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnQ09OVEFJTkVSLUJPVFRPTSc6XHJcbiAgICAgICAgICBjYXNlICdWSUVXUE9SVC1VTkJPVFRPTSc6XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2xhdGUgPSB0aGlzLl9nZXRUcmFuc2xhdGUoMCwgZGltcy50cmFuc2xhdGVZICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiggdHJhbnNsYXRlIClcclxuICAgICAgICAgICAgICBzdHlsZS5pbm5lciA9IHt0cmFuc2Zvcm06IHRyYW5zbGF0ZX07XHJcbiAgICAgICAgICAgIGVsc2UgXHJcbiAgICAgICAgICAgICAgc3R5bGUuaW5uZXIgPSB7cG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogZGltcy50cmFuc2xhdGVZLCB3aWR0aDogZGltcy5zaWRlYmFyV2lkdGh9O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoKCBhZmZpeFR5cGUgKXtcclxuICAgICAgICAgIGNhc2UgJ1ZJRVdQT1JULVRPUCc6XHJcbiAgICAgICAgICBjYXNlICdWSUVXUE9SVC1CT1RUT00nOlxyXG4gICAgICAgICAgY2FzZSAnVklFV1BPUlQtVU5CT1RUT00nOlxyXG4gICAgICAgICAgY2FzZSAnQ09OVEFJTkVSLUJPVFRPTSc6XHJcbiAgICAgICAgICAgIHN0eWxlLm91dGVyID0ge2hlaWdodDogZGltcy5zaWRlYmFySGVpZ2h0LCBwb3NpdGlvbjogJ3JlbGF0aXZlJ307XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBzdHlsZS5vdXRlciA9IFN0aWNreVNpZGViYXIuZXh0ZW5kKHtoZWlnaHQ6ICcnLCBwb3NpdGlvbjogJyd9LCBzdHlsZS5vdXRlcik7XHJcbiAgICAgICAgc3R5bGUuaW5uZXIgPSBTdGlja3lTaWRlYmFyLmV4dGVuZCh7cG9zaXRpb246ICdyZWxhdGl2ZScsIHRvcDogJycsIGxlZnQ6ICcnLFxyXG4gICAgICAgICAgICBib3R0b206ICcnLCB3aWR0aDogJycsICB0cmFuc2Zvcm06IHRoaXMuX2dldFRyYW5zbGF0ZSgpfSwgc3R5bGUuaW5uZXIpO1xyXG4gIFxyXG4gICAgICAgIHJldHVybiBzdHlsZTtcclxuICAgICAgfVxyXG4gICAgIFxyXG4gICAgICAvKipcclxuICAgICAgICogQ2F1c2UgdGhlIHNpZGViYXIgdG8gYmUgc3RpY2t5IGFjY29yZGluZyB0byBhZmZpeCB0eXBlIGJ5IGFkZGluZyBpbmxpbmVcclxuICAgICAgICogc3R5bGUsIGFkZGluZyBoZWxwZXIgY2xhc3MgYW5kIHRyaWdnZXIgZXZlbnRzLlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9yY2UgLSBVcGRhdGUgc3RpY2t5IHNpZGViYXIgcG9zaXRpb24gYnkgZm9yY2UuXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGlja3lQb3NpdGlvbihmb3JjZSl7XHJcbiAgICAgICAgaWYoIHRoaXMuX2JyZWFrcG9pbnQgKSByZXR1cm47XHJcbiAgXHJcbiAgICAgICAgZm9yY2UgPSB0aGlzLl9yZVN0eWxlIHx8IGZvcmNlIHx8IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBvZmZzZXRUb3AgPSB0aGlzLm9wdGlvbnMudG9wU3BhY2luZztcclxuICAgICAgICB2YXIgb2Zmc2V0Qm90dG9tID0gdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmc7XHJcbiAgXHJcbiAgICAgICAgdmFyIGFmZml4VHlwZSA9IHRoaXMuZ2V0QWZmaXhUeXBlKCk7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGUoYWZmaXhUeXBlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiggKHRoaXMuYWZmaXhlZFR5cGUgIT0gYWZmaXhUeXBlIHx8IGZvcmNlKSAmJiBhZmZpeFR5cGUgKXtcclxuICAgICAgICAgIGxldCBhZmZpeEV2ZW50ID0gJ2FmZml4LicgKyBhZmZpeFR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCd2aWV3cG9ydC0nLCAnJykgKyBFVkVOVF9LRVk7XHJcbiAgICAgICAgICBTdGlja3lTaWRlYmFyLmV2ZW50VHJpZ2dlcih0aGlzLnNpZGViYXIsIGFmZml4RXZlbnQpO1xyXG4gIFxyXG4gICAgICAgICAgaWYoICdTVEFUSUMnID09PSBhZmZpeFR5cGUgKVxyXG4gICAgICAgICAgICBTdGlja3lTaWRlYmFyLnJlbW92ZUNsYXNzKHRoaXMuc2lkZWJhciwgdGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgU3RpY2t5U2lkZWJhci5hZGRDbGFzcyh0aGlzLnNpZGViYXIsIHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciggbGV0IGtleSBpbiBzdHlsZS5vdXRlciApe1xyXG4gICAgICAgICAgICBsZXQgX3VuaXQgPSAoJ251bWJlcicgPT09IHR5cGVvZiBzdHlsZS5vdXRlcltrZXldKSA/ICdweCcgOiAnJztcclxuICAgICAgICAgICAgdGhpcy5zaWRlYmFyLnN0eWxlW2tleV0gPSBzdHlsZS5vdXRlcltrZXldO1xyXG4gICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgZm9yKCBsZXQga2V5IGluIHN0eWxlLmlubmVyICl7XHJcbiAgICAgICAgICAgIGxldCBfdW5pdCA9ICgnbnVtYmVyJyA9PT0gdHlwZW9mIHN0eWxlLmlubmVyW2tleV0pID8gJ3B4JyA6ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnNpZGViYXJJbm5lci5zdHlsZVtrZXldID0gc3R5bGUuaW5uZXJba2V5XSArIF91bml0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgYWZmaXhlZEV2ZW50ID0gJ2FmZml4ZWQuJysgYWZmaXhUeXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgndmlld3BvcnQtJywgJycpICsgRVZFTlRfS0VZO1xyXG4gICAgICAgICAgU3RpY2t5U2lkZWJhci5ldmVudFRyaWdnZXIodGhpcy5zaWRlYmFyLCBhZmZpeGVkRXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiggdGhpcy5faW5pdGlhbGl6ZWQgKSB0aGlzLnNpZGViYXJJbm5lci5zdHlsZS5sZWZ0ID0gc3R5bGUuaW5uZXIubGVmdDtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgdGhpcy5hZmZpeGVkVHlwZSA9IGFmZml4VHlwZTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogQnJlYWtkb3duIHN0aWNreSBzaWRlYmFyIHdoZW4gd2luZG93IHdpZHRoIGlzIGJlbG93IGBvcHRpb25zLm1pbldpZHRoYCB2YWx1ZS5cclxuICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgKi9cclxuICAgICAgX3dpZHRoQnJlYWtwb2ludCgpe1xyXG4gIFxyXG4gICAgICAgIGlmKCB3aW5kb3cuaW5uZXJXaWR0aCA8PSB0aGlzLm9wdGlvbnMubWluV2lkdGggKXtcclxuICAgICAgICAgIHRoaXMuX2JyZWFrcG9pbnQgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5hZmZpeGVkVHlwZSA9ICdTVEFUSUMnO1xyXG4gIFxyXG4gICAgICAgICAgdGhpcy5zaWRlYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgICAgICAgIFN0aWNreVNpZGViYXIucmVtb3ZlQ2xhc3ModGhpcy5zaWRlYmFyLCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpO1xyXG4gICAgICAgICAgdGhpcy5zaWRlYmFySW5uZXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLl9icmVha3BvaW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIGZ1bmN0aW9ucyBzdGFjayBmb3IgZWFjaCBldmVudCB0eXBlLCBpZiB0aGVyZSdzIG5vIFxyXG4gICAgICAgKiBldmVudCwgaXQgd2lsbCByZS1pbml0aWFsaXplIHN0aWNreSBzaWRlYmFyLlxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqL1xyXG4gICAgICB1cGRhdGVTdGlja3koZXZlbnQgPSB7fSl7XHJcbiAgICAgICAgaWYoIHRoaXMuX3J1bm5pbmcgKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgXHJcbiAgICAgICAgKChldmVudFR5cGUpID0+IHtcclxuXHJcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2goIGV2ZW50VHlwZSApe1xyXG4gICAgICAgICAgICAgIC8vIFdoZW4gYnJvd3NlciBpcyBzY3JvbGxpbmcgYW5kIHJlLWNhbGN1bGF0ZSBqdXN0IGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICAvLyB3aXRoaW4gc2Nyb2xsLiBcclxuICAgICAgICAgICAgICBjYXNlICdzY3JvbGwnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVTY3JvbGxEaXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gIFxyXG4gICAgICAgICAgICAgIC8vIFdoZW4gYnJvd3NlciBpcyByZXNpemluZyBvciB0aGVyZSdzIG5vIGV2ZW50LCBvYnNlcnZlIHdpZHRoXHJcbiAgICAgICAgICAgICAgLy8gYnJlYWtwb2ludCBhbmQgcmUtY2FsY3VsYXRlIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgICAgY2FzZSAncmVzaXplJzpcclxuICAgICAgICAgICAgICBkZWZhdWx0OiBcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQnJlYWtwb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjRGltZW5zaW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGlja3lQb3NpdGlvbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKGV2ZW50LnR5cGUpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBTZXQgYnJvd3NlciBzdXBwb3J0IGZlYXR1cmVzIHRvIHRoZSBwdWJsaWMgcHJvcGVydHkuXHJcbiAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAqL1xyXG4gICAgICBfc2V0U3VwcG9ydEZlYXR1cmVzKCl7XHJcbiAgICAgICAgdmFyIHN1cHBvcnQgPSB0aGlzLnN1cHBvcnQ7XHJcbiAgXHJcbiAgICAgICAgc3VwcG9ydC50cmFuc2Zvcm0gPSBTdGlja3lTaWRlYmFyLnN1cHBvcnRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBzdXBwb3J0LnRyYW5zZm9ybTNkID0gU3RpY2t5U2lkZWJhci5zdXBwb3J0VHJhbnNmb3JtKHRydWUpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBHZXQgdHJhbnNsYXRlIHZhbHVlLCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0cmFuc2Zyb20zZCwgaXQgd2lsbCBhZG9wdCBpdC5cclxuICAgICAgICogYW5kIHRoZSBzYW1lIHdpdGggdHJhbnNsYXRlLiBpZiBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBib3RoIHJldHVybiBmYWxzZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBWYWx1ZSBvZiBZLWF4aXMuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVmFsdWUgb2YgWC1heGlzLlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geiAtIFZhbHVlIG9mIFotYXhpcy5cclxuICAgICAgICogQHJldHVybiB7U3RyaW5nfEZhbHNlfVxyXG4gICAgICAgKi9cclxuICAgICAgX2dldFRyYW5zbGF0ZSh5ID0gMCwgeCA9IDAsIHogPSAwKXtcclxuICAgICAgICBpZiggdGhpcy5zdXBwb3J0LnRyYW5zZm9ybTNkICkgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgeSArJywgJysgeCArJywgJysgeiArJyknO1xyXG4gICAgICAgIGVsc2UgaWYoIHRoaXMuc3VwcG9ydC50cmFuc2xhdGUgKSByZXR1cm4gJ3RyYW5zbGF0ZSgnKyB5ICsnLCAnKyB4ICsnKSc7XHJcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgLyoqXHJcbiAgICAgICAqIERlc3Ryb3kgc3RpY2t5IHNpZGViYXIgcGx1Z2luLlxyXG4gICAgICAgKiBAcHVibGljXHJcbiAgICAgICAqL1xyXG4gICAgICBkZXN0cm95KCl7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMsIHtjYXB0aW9uOiBmYWxzZX0pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB7Y2FwdGlvbjogZmFsc2V9KTtcclxuICBcclxuICAgICAgICB0aGlzLnNpZGViYXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpO1xyXG4gICAgICAgIHRoaXMuc2lkZWJhci5zdHlsZS5taW5IZWlnaHQgPSAnJztcclxuICBcclxuICAgICAgICB0aGlzLnNpZGViYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXBkYXRlJyArIEVWRU5UX0tFWSwgdGhpcyk7XHJcbiAgXHJcbiAgICAgICAgdmFyIHN0eWxlUmVzZXQgPSB7aW5uZXI6IHt9LCBvdXRlcjoge319O1xyXG4gIFxyXG4gICAgICAgIHN0eWxlUmVzZXQuaW5uZXIgPSB7cG9zaXRpb246ICcnLCB0b3A6ICcnLCBsZWZ0OiAnJywgYm90dG9tOiAnJywgd2lkdGg6ICcnLCAgdHJhbnNmb3JtOiAnJ307XHJcbiAgICAgICAgc3R5bGVSZXNldC5vdXRlciA9IHtoZWlnaHQ6ICcnLCBwb3NpdGlvbjogJyd9O1xyXG4gIFxyXG4gICAgICAgIGZvciggbGV0IGtleSBpbiBzdHlsZVJlc2V0Lm91dGVyIClcclxuICAgICAgICAgIHRoaXMuc2lkZWJhci5zdHlsZVtrZXldID0gc3R5bGVSZXNldC5vdXRlcltrZXldO1xyXG4gIFxyXG4gICAgICAgIGZvciggbGV0IGtleSBpbiBzdHlsZVJlc2V0LmlubmVyIClcclxuICAgICAgICAgIHRoaXMuc2lkZWJhcklubmVyLnN0eWxlW2tleV0gPSBzdHlsZVJlc2V0LmlubmVyW2tleV07XHJcbiAgXHJcbiAgICAgICAgaWYoIHRoaXMub3B0aW9ucy5yZXNpemVTZW5zb3IgJiYgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBSZXNpemVTZW5zb3IgKXtcclxuICAgICAgICAgIFJlc2l6ZVNlbnNvci5kZXRhY2godGhpcy5zaWRlYmFySW5uZXIsIHRoaXMuaGFuZGxlRXZlbnQpO1xyXG4gICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaCh0aGlzLmNvbnRhaW5lciwgdGhpcy5oYW5kbGVFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgQ1NTIHRyYW5zZm9ybSBmZWF0dXJlLlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRyYW5zZm9ybTNkIC0gRGV0ZWN0IHRyYW5zZm9ybSB3aXRoIHRyYW5zbGF0ZTNkLlxyXG4gICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgc3VwcG9ydFRyYW5zZm9ybSh0cmFuc2Zvcm0zZCl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9ICh0cmFuc2Zvcm0zZCkgPyAncGVyc3BlY3RpdmUnIDogJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgICAgIHVwcGVyID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKSxcclxuICAgICAgICAgICAgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddLFxyXG4gICAgICAgICAgICBzdXBwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3VwcG9ydCcpLFxyXG4gICAgICAgICAgICBzdHlsZSA9IHN1cHBvcnQuc3R5bGU7XHJcbiAgXHJcbiAgICAgICAgKHByb3BlcnR5ICsgJyAnICsgcHJlZml4ZXMuam9pbih1cHBlciArICcgJykgKyB1cHBlcikuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5LCBpKSB7XHJcbiAgICAgICAgICBpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUcmlnZ2VyIGN1c3RvbSBldmVudC5cclxuICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgKiBAcGFyYW0ge0RPTU9iamVjdH0gZWxlbWVudCAtIFRhcmdldCBlbGVtZW50IG9uIHRoZSBET00uXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgLSBFdmVudCBuYW1lLlxyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFxyXG4gICAgICAgKi9cclxuICAgICAgc3RhdGljIGV2ZW50VHJpZ2dlcihlbGVtZW50LCBldmVudE5hbWUsIGRhdGEpe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtkZXRhaWw6IGRhdGF9KTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XHJcbiAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogRXh0ZW5kIG9wdGlvbnMgb2JqZWN0IHdpdGggZGVmYXVsdHMuXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgZXh0ZW5kKGRlZmF1bHRzLCBvcHRpb25zKXtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gICAgICAgIGZvciggbGV0IGtleSBpbiBkZWZhdWx0cyApe1xyXG4gICAgICAgICAgaWYoICd1bmRlZmluZWQnICE9PSB0eXBlb2Ygb3B0aW9uc1trZXldICkgcmVzdWx0c1trZXldID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgZWxzZSByZXN1bHRzW2tleV0gPSBkZWZhdWx0c1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogR2V0IGN1cnJlbnQgY29vcmRpbmF0ZXMgbGVmdCBhbmQgdG9wIG9mIHNwZWNpZmljIGVsZW1lbnQuXHJcbiAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICovXHJcbiAgICAgIHN0YXRpYyBvZmZzZXRSZWxhdGl2ZShlbGVtZW50KXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IDAsIHRvcDogMH07XHJcblxyXG4gICAgICAgIGRve1xyXG4gICAgICAgICAgbGV0IG9mZnNldFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgbGV0IG9mZnNldExlZnQgPSBlbGVtZW50Lm9mZnNldExlZnQ7XHJcbiAgXHJcbiAgICAgICAgICBpZiggISBpc05hTihvZmZzZXRUb3ApIClcclxuICAgICAgICAgICAgcmVzdWx0LnRvcCArPSBvZmZzZXRUb3A7XHJcbiAgXHJcbiAgICAgICAgICBpZiggISBpc05hTihvZmZzZXRMZWZ0KSApXHJcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0ICs9IG9mZnNldExlZnQ7XHJcblxyXG4gICAgICAgICAgZWxlbWVudCA9ICggJ0JPRFknID09PSBlbGVtZW50LnRhZ05hbWUgKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudEVsZW1lbnQgOiBlbGVtZW50Lm9mZnNldFBhcmVudDtcclxuICAgICAgICB9IHdoaWxlKGVsZW1lbnQpXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICAvKipcclxuICAgICAgICogQWRkIHNwZWNpZmljIGNsYXNzIG5hbWUgdG8gc3BlY2lmaWMgZWxlbWVudC5cclxuICAgICAgICogQHN0YXRpYyBcclxuICAgICAgICogQHBhcmFtIHtPYmplY3RET019IGVsZW1lbnQgXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKXtcclxuICAgICAgICBpZiggISBTdGlja3lTaWRlYmFyLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkgKXtcclxuICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdClcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBSZW1vdmUgc3BlY2lmaWMgY2xhc3MgbmFtZSB0byBzcGVjaWZpYyBlbGVtZW50XHJcbiAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICogQHBhcmFtIHtPYmplY3RET019IGVsZW1lbnQgXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgXHJcbiAgICAgICAqL1xyXG4gICAgICBzdGF0aWMgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKXtcclxuICAgICAgICBpZiggU3RpY2t5U2lkZWJhci5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpICl7XHJcbiAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpXHJcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXGIpJyArIGNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoXFxcXGJ8JCknLCAnZ2knKSwgJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXRlcm1pbmUgd2VhdGhlciB0aGUgZWxlbWVudCBoYXMgc3BlY2lmaWMgY2xhc3MgbmFtZS5cclxuICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgKiBAcGFyYW0ge09iamVjdERPTX0gZWxlbWVudCBcclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBcclxuICAgICAgICovXHJcbiAgICAgIHN0YXRpYyBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpe1xyXG4gICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdClcclxuICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCcoXnwgKScgKyBjbGFzc05hbWUgKyAnKCB8JCknLCAnZ2knKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgcmV0dXJuIFN0aWNreVNpZGViYXI7XHJcbiAgfSkoKTtcclxuICBcclxuICBleHBvcnQgZGVmYXVsdCBTdGlja3lTaWRlYmFyO1xyXG4gIFxyXG4gIC8vIEdsb2JhbFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICB3aW5kb3cuU3RpY2t5U2lkZWJhciA9IFN0aWNreVNpZGViYXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/sticky-sidebar/src/sticky-sidebar.js\n");

/***/ }),

/***/ "./components/resizeSensor.js":
/*!************************************!*\
  !*** ./components/resizeSensor.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\r\n * directory of this distribution and at\r\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\r\n */\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(typeof window !== 'undefined' ? window : undefined, function () {\n\n    // Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // https://github.com/Semantic-Org/Semantic-UI/issues/3855\n    // https://github.com/marcj/css-element-queries/issues/257\n    var globalWindow = typeof window !== 'undefined' && window.Math == Math ? window : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')();\n    // Only used for the dirty checking, so the event callback count is limited to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = globalWindow.requestAnimationFrame || globalWindow.mozRequestAnimationFrame || globalWindow.webkitRequestAnimationFrame || function (fn) {\n        return globalWindow.setTimeout(fn, 20);\n    };\n\n    /**\r\n     * Iterate over each of the provided element(s).\r\n     *\r\n     * @param {HTMLElement|HTMLElement[]} elements\r\n     * @param {Function}                  callback\r\n     */\n    function forEachElement(elements, callback) {\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = elementsType === '[object Array]' || elementsType === '[object NodeList]' || elementsType === '[object HTMLCollection]' || elementsType === '[object Object]' || typeof jQuery !== 'undefined' && elements instanceof jQuery // jquery\n        || typeof Elements !== 'undefined' && elements instanceof Elements // mootools\n        ;\n        var i = 0;var j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\r\n    * Get element size\r\n    * @param {HTMLElement} element\r\n    * @returns {Object} {width, height}\r\n    */\n    function getElementSize(element) {\n        if (!element.getBoundingClientRect) {\n            return {\n                width: element.offsetWidth,\n                height: element.offsetHeight\n            };\n        }\n\n        var rect = element.getBoundingClientRect();\n        return {\n            width: Math.round(rect.width),\n            height: Math.round(rect.height)\n        };\n    }\n\n    /**\r\n     * Apply CSS styles to element.\r\n     *\r\n     * @param {HTMLElement} element\r\n     * @param {Object} style\r\n     */\n    function setStyle(element, style) {\n        Object.keys(style).forEach(function (key) {\n            element.style[key] = style[key];\n        });\n    }\n\n    /**\r\n     * Class for dimension change detection.\r\n     *\r\n     * @param {Element|Element[]|Elements|jQuery} element\r\n     * @param {Function} callback\r\n     *\r\n     * @constructor\r\n     */\n    var ResizeSensor = function ResizeSensor(element, callback) {\n        /**\r\n         *\r\n         * @constructor\r\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function (ev) {\n                q.push(ev);\n            };\n\n            var i = void 0;var j;\n            this.call = function (sizeInfo) {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call(this, sizeInfo);\n                }\n            };\n\n            this.remove = function (ev) {\n                var newQueue = [];\n                for (i = 0, j = q.length; i < j; i++) {\n                    if (q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            };\n\n            this.length = function () {\n                return q.length;\n            };\n        }\n\n        /**\r\n         *\r\n         * @param {HTMLElement} element\r\n         * @param {Function}    resized\r\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element) return;\n            if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizedAttached = new EventQueue();\n            element.resizedAttached.add(resized);\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.dir = 'ltr';\n            element.resizeSensor.className = 'resize-sensor';\n\n            var style = {\n                pointerEvents: 'none',\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                right: '0px',\n                bottom: '0px',\n                overflow: 'hidden',\n                zIndex: '-1',\n                visibility: 'hidden',\n                maxWidth: '100%'\n            };\n            var styleChild = {\n                position: 'absolute',\n                left: '0px',\n                top: '0px',\n                transition: '0s'\n            };\n\n            setStyle(element.resizeSensor, style);\n\n            var expand = document.createElement('div');\n            expand.className = 'resize-sensor-expand';\n            setStyle(expand, style);\n\n            var expandChild = document.createElement('div');\n            setStyle(expandChild, styleChild);\n            expand.appendChild(expandChild);\n\n            var shrink = document.createElement('div');\n            shrink.className = 'resize-sensor-shrink';\n            setStyle(shrink, style);\n\n            var shrinkChild = document.createElement('div');\n            setStyle(shrinkChild, styleChild);\n            setStyle(shrinkChild, { width: '200%', height: '200%' });\n            shrink.appendChild(shrinkChild);\n\n            element.resizeSensor.appendChild(expand);\n            element.resizeSensor.appendChild(shrink);\n            element.appendChild(element.resizeSensor);\n\n            var computedStyle = window.getComputedStyle(element);\n            var position = computedStyle ? computedStyle.getPropertyValue('position') : null;\n            if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\n                element.style.position = 'relative';\n            }\n\n            var dirty = void 0;var rafId;\n            var size = getElementSize(element);\n            var lastWidth = 0;\n            var lastHeight = 0;\n            var initialHiddenCheck = true;\n            var lastAnimationFrame = 0;\n\n            var resetExpandShrink = function resetExpandShrink() {\n                var width = element.offsetWidth;\n                var height = element.offsetHeight;\n\n                expandChild.style.width = width + 10 + \"px\";\n                expandChild.style.height = height + 10 + \"px\";\n\n                expand.scrollLeft = width + 10;\n                expand.scrollTop = height + 10;\n\n                shrink.scrollLeft = width + 10;\n                shrink.scrollTop = height + 10;\n            };\n\n            var reset = function reset() {\n                // Check if element is hidden\n                if (initialHiddenCheck) {\n                    var invisible = element.offsetWidth === 0 && element.offsetHeight === 0;\n                    if (invisible) {\n                        // Check in next frame\n                        if (!lastAnimationFrame) {\n                            lastAnimationFrame = requestAnimationFrame(function () {\n                                lastAnimationFrame = 0;\n\n                                reset();\n                            });\n                        }\n\n                        return;\n                    }\n                    // Stop checking\n                    initialHiddenCheck = false;\n                }\n\n                resetExpandShrink();\n            };\n            element.resizeSensor.resetSensor = reset;\n\n            var onResized = function onResized() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = size.width;\n                lastHeight = size.height;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call(size);\n                }\n            };\n\n            var onScroll = function onScroll() {\n                size = getElementSize(element);\n                dirty = size.width !== lastWidth || size.height !== lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function addEvent(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent(\"on\" + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n\n            // Fix for custom Elements\n            requestAnimationFrame(reset);\n        }\n\n        forEachElement(element, function (elem) {\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function (ev) {\n            ResizeSensor.detach(element, ev);\n        };\n\n        this.reset = function () {\n            element.resizeSensor.resetSensor();\n        };\n    };\n\n    ResizeSensor.reset = function (element) {\n        forEachElement(element, function (elem) {\n            elem.resizeSensor.resetSensor();\n        });\n    };\n\n    ResizeSensor.detach = function (element, ev) {\n        forEachElement(element, function (elem) {\n            if (!elem) return;\n            if (elem.resizedAttached && typeof ev === \"function\") {\n                elem.resizedAttached.remove(ev);\n                if (elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    if (typeof MutationObserver !== \"undefined\") {\n        var observer = new MutationObserver(function (mutations) {\n            for (var i in mutations) {\n                if (mutations.hasOwnProperty(i)) {\n                    var items = mutations[i].addedNodes;\n                    for (var j = 0; j < items.length; j++) {\n                        if (items[j].resizeSensor) {\n                            ResizeSensor.reset(items[j]);\n                        }\n                    }\n                }\n            }\n        });\n\n        document.addEventListener(\"DOMContentLoaded\", function (event) {\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        });\n    }\n\n    return ResizeSensor;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3Jlc2l6ZVNlbnNvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9yZXNpemVTZW5zb3IuanM/ODYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbi8qKlxyXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXHJcbiAqIGRpcmVjdG9yeSBvZiB0aGlzIGRpc3RyaWJ1dGlvbiBhbmQgYXRcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5cclxuICovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290LlJlc2l6ZVNlbnNvciA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgZG9lcyBub3QgdGhyb3cgaW4gYSBTU1IgKFNlcnZlciBTaWRlIFJlbmRlcmluZykgc2l0dWF0aW9uXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1NlbWFudGljLU9yZy9TZW1hbnRpYy1VSS9pc3N1ZXMvMzg1NVxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXMvaXNzdWVzLzI1N1xyXG4gICAgbGV0IGdsb2JhbFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcclxuICAgICAgICA/IHdpbmRvd1xyXG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoXHJcbiAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbiAgICAvLyBPbmx5IHVzZWQgZm9yIHRoZSBkaXJ0eSBjaGVja2luZywgc28gdGhlIGV2ZW50IGNhbGxiYWNrIGNvdW50IGlzIGxpbWl0ZWQgdG8gbWF4IDEgY2FsbCBwZXIgZnBzIHBlciBzZW5zb3IuXHJcbiAgICAvLyBJbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBldmVudCBiYXNlZCByZXNpemUgc2Vuc29yIHRoaXMgc2F2ZXMgY3B1IHRpbWUsIGJlY2F1c2UgdGhlIHNlbnNvciBpcyB0b28gZmFzdCBhbmRcclxuICAgIC8vIHdvdWxkIGdlbmVyYXRlIHRvbyBtYW55IHVubmVjZXNzYXJ5IGV2ZW50cy5cclxuICAgIGxldCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBnbG9iYWxXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgZ2xvYmFsV2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgIGdsb2JhbFdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFdpbmRvdy5zZXRUaW1lb3V0KGZuLCAyMCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG9mIHRoZSBwcm92aWRlZCBlbGVtZW50KHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTEVsZW1lbnRbXX0gZWxlbWVudHNcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgICAgICAgICAgICAgICAgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9yRWFjaEVsZW1lbnQoZWxlbWVudHMsIGNhbGxiYWNrKXtcclxuICAgICAgICBsZXQgZWxlbWVudHNUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnRzKTtcclxuICAgICAgICBsZXQgaXNDb2xsZWN0aW9uVHlwZWQgPSAoZWxlbWVudHNUeXBlID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScpXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpXHJcbiAgICAgICAgICAgIHx8IChlbGVtZW50c1R5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKVxyXG4gICAgICAgICAgICB8fCAodHlwZW9mIGpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgJiYgZWxlbWVudHMgaW5zdGFuY2VvZiBqUXVlcnkpIC8vIGpxdWVyeVxyXG4gICAgICAgICAgICB8fCAodHlwZW9mIEVsZW1lbnRzICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50cyBpbnN0YW5jZW9mIEVsZW1lbnRzKSAvLyBtb290b29sc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IGkgPSAwOyB2YXIgaiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZWQpIHtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEdldCBlbGVtZW50IHNpemVcclxuICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSB7d2lkdGgsIGhlaWdodH1cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2l6ZShlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChyZWN0LndpZHRoKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IENTUyBzdHlsZXMgdG8gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGUpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIGZvciBkaW1lbnNpb24gY2hhbmdlIGRldGVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfEVsZW1lbnRzfGpRdWVyeX0gZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFJlc2l6ZVNlbnNvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKCkge1xyXG4gICAgICAgICAgICBsZXQgcSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBxLnB1c2goZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgbGV0IGk7IHZhciBqO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGwgPSBmdW5jdGlvbihzaXplSW5mbykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcVtpXS5jYWxsKHRoaXMsIHNpemVJbmZvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdRdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwLCBqID0gcS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihxW2ldICE9PSBldikgbmV3UXVldWUucHVzaChxW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHEgPSBuZXdRdWV1ZTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIHJlc2l6ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCByZXNpemVkKSB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5kaXIgPSAnbHRyJztcclxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xyXG5cclxuICAgICAgICAgICAgbGV0IHN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMHB4JyxcclxuICAgICAgICAgICAgICAgIHRvcDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICByaWdodDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICBib3R0b206ICcwcHgnLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiAnLTEnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBzdHlsZUNoaWxkID0ge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiAnMHB4JyxcclxuICAgICAgICAgICAgICAgIHRvcDogJzBweCcsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnMHMnLFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2V0U3R5bGUoZWxlbWVudC5yZXNpemVTZW5zb3IsIHN0eWxlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBleHBhbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgZXhwYW5kLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yLWV4cGFuZCc7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKGV4cGFuZCwgc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGV4cGFuZENoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKGV4cGFuZENoaWxkLCBzdHlsZUNoaWxkKTtcclxuICAgICAgICAgICAgZXhwYW5kLmFwcGVuZENoaWxkKGV4cGFuZENoaWxkKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzaHJpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgc2hyaW5rLmNsYXNzTmFtZSA9ICdyZXNpemUtc2Vuc29yLXNocmluayc7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHNocmluaywgc3R5bGUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNocmlua0NoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHNldFN0eWxlKHNocmlua0NoaWxkLCBzdHlsZUNoaWxkKTtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc2hyaW5rQ2hpbGQsIHsgd2lkdGg6ICcyMDAlJywgaGVpZ2h0OiAnMjAwJScgfSk7XHJcbiAgICAgICAgICAgIHNocmluay5hcHBlbmRDaGlsZChzaHJpbmtDaGlsZCk7XHJcblxyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5hcHBlbmRDaGlsZChleHBhbmQpO1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5hcHBlbmRDaGlsZChzaHJpbmspO1xyXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQucmVzaXplU2Vuc29yKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUgPyBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdyZWxhdGl2ZScgJiYgcG9zaXRpb24gIT09ICdmaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZGlydHk7IHZhciByYWZJZDtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSBnZXRFbGVtZW50U2l6ZShlbGVtZW50KTtcclxuICAgICAgICAgICAgbGV0IGxhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBsYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgbGV0IGluaXRpYWxIaWRkZW5DaGVjayA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBsYXN0QW5pbWF0aW9uRnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc2V0RXhwYW5kU2hyaW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9IGAke3dpZHRoICsgMTAgIH1weGA7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHQgKyAxMCAgfXB4YDtcclxuXHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IHdpZHRoICsgMTA7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQuc2Nyb2xsVG9wID0gaGVpZ2h0ICsgMTA7XHJcblxyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbExlZnQgPSB3aWR0aCArIDEwO1xyXG4gICAgICAgICAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IGhlaWdodCArIDEwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaWRkZW5DaGVjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnZpc2libGUgPSBlbGVtZW50Lm9mZnNldFdpZHRoID09PSAwICYmIGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID09PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaW4gbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RBbmltYXRpb25GcmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QW5pbWF0aW9uRnJhbWUgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGNoZWNraW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxIaWRkZW5DaGVjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc2V0RXhwYW5kU2hyaW5rKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVsZW1lbnQucmVzaXplU2Vuc29yLnJlc2V0U2Vuc29yID0gcmVzZXQ7XHJcblxyXG4gICAgICAgICAgICBsZXQgb25SZXNpemVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByYWZJZCA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RXaWR0aCA9IHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBsYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQuY2FsbChzaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxldCBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IGdldEVsZW1lbnRTaXplKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZGlydHkgPSBzaXplLndpZHRoICE9PSBsYXN0V2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IGxhc3RIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5ICYmICFyYWZJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uUmVzaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoYG9uJHsgIG5hbWV9YCwgY2IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50KGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcclxuICAgICAgICAgICAgYWRkRXZlbnQoc2hyaW5rLCAnc2Nyb2xsJywgb25TY3JvbGwpO1xyXG5cclxuICAgICAgICAgICAgLy8gRml4IGZvciBjdXN0b20gRWxlbWVudHNcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvckVhY2hFbGVtZW50KGVsZW1lbnQsIGZ1bmN0aW9uKGVsZW0pe1xyXG4gICAgICAgICAgICBhdHRhY2hSZXNpemVFdmVudChlbGVtLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oZXYpIHtcclxuICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50LCBldik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvci5yZXNldFNlbnNvcigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIFJlc2l6ZVNlbnNvci5yZXNldCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcclxuICAgICAgICAgICAgZWxlbS5yZXNpemVTZW5zb3IucmVzZXRTZW5zb3IoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVzaXplU2Vuc29yLmRldGFjaCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2KSB7XHJcbiAgICAgICAgZm9yRWFjaEVsZW1lbnQoZWxlbWVudCwgZnVuY3Rpb24oZWxlbSl7XHJcbiAgICAgICAgICAgIGlmICghZWxlbSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihlbGVtLnJlc2l6ZWRBdHRhY2hlZCAmJiB0eXBlb2YgZXYgPT09IFwiZnVuY3Rpb25cIil7XHJcbiAgICAgICAgICAgICAgICBlbGVtLnJlc2l6ZWRBdHRhY2hlZC5yZW1vdmUoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYoZWxlbS5yZXNpemVkQXR0YWNoZWQubGVuZ3RoKCkpIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZWxlbS5yZXNpemVTZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNvbnRhaW5zKGVsZW0ucmVzaXplU2Vuc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQ2hpbGQoZWxlbS5yZXNpemVTZW5zb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplU2Vuc29yO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplZEF0dGFjaGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBtdXRhdGlvbnNbaV0uYWRkZWROb2RlcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtc1tqXS5yZXNpemVTZW5zb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlc2l6ZVNlbnNvci5yZXNldChpdGVtc1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlc2l6ZVNlbnNvcjtcclxuXHJcbn0pKTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxhQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/resizeSensor.js\n");

/***/ }),

/***/ "./components/sticky.js":
/*!******************************!*\
  !*** ./components/sticky.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sidebar = undefined;\n\n__webpack_require__(/*! ./resizeSensor */ \"./components/resizeSensor.js\");\n\n__webpack_require__(/*! sticky-sidebar */ \"../../node_modules/sticky-sidebar/src/sticky-sidebar.js\");\n\nvar sidebar = exports.sidebar = new StickySidebar('.js-sticky', {\n  topSpacing: 0,\n  responsiveWidth: true,\n  resizeSensor: true\n\n});\n\nvar stickyInterval;\nstickyInterval = setInterval(function () {\n  if (sidebar) {\n    sidebar.updateSticky();\n  }\n}, 500);\n\n// navigation podmenu\n$('.navigation-module ul li').each(function () {\n\n  if ($(this).find('ul').length) {\n\n    $(this).children('a').click(function (e) {\n      if (!$(this).parent().hasClass('active')) {\n        e.preventDefault();\n        // удалить у всех active\n        $('.navigation-module ul li ul').slideUp();\n        $('.navigation-module ul li').removeClass('active');\n        // добавить active\n        $(this).parent().find('ul').slideDown();\n        $(this).parent().toggleClass('active');\n        sidebar.updateSticky();\n      } else {\n        e.preventDefault();\n        $(this).parent().find('ul').slideUp();\n        $(this).parent().toggleClass('active');\n        sidebar.updateSticky();\n      }\n    });\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL3N0aWNreS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9zdGlja3kuanM/ZDVhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vcmVzaXplU2Vuc29yJztcclxuaW1wb3J0ICdzdGlja3ktc2lkZWJhcic7XHJcblxyXG5leHBvcnQgbGV0IHNpZGViYXIgPSBuZXcgU3RpY2t5U2lkZWJhcignLmpzLXN0aWNreScsIHtcclxuICB0b3BTcGFjaW5nOiAwLFxyXG4gIHJlc3BvbnNpdmVXaWR0aDogdHJ1ZSxcclxuICByZXNpemVTZW5zb3I6IHRydWUsXHJcblxyXG59KTtcclxuXHJcbnZhciBzdGlja3lJbnRlcnZhbDtcclxuc3RpY2t5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHNpZGViYXIpIHtcclxuICAgIHNpZGViYXIudXBkYXRlU3RpY2t5KCk7XHJcbiAgfVxyXG59LCA1MDApO1xyXG5cclxuLy8gbmF2aWdhdGlvbiBwb2RtZW51XHJcbiQoJy5uYXZpZ2F0aW9uLW1vZHVsZSB1bCBsaScpLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cclxuICBpZiAoJCh0aGlzKS5maW5kKCd1bCcpLmxlbmd0aCkge1xyXG5cclxuICAgICQodGhpcykuY2hpbGRyZW4oJ2EnKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICBpZiAoISQodGhpcykucGFyZW50KCkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIC8vINGD0LTQsNC70LjRgtGMINGDINCy0YHQtdGFIGFjdGl2ZVxyXG4gICAgICAgICQoJy5uYXZpZ2F0aW9uLW1vZHVsZSB1bCBsaSB1bCcpLnNsaWRlVXAoKTtcclxuICAgICAgICAkKCcubmF2aWdhdGlvbi1tb2R1bGUgdWwgbGknKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgLy8g0LTQvtCx0LDQstC40YLRjCBhY3RpdmVcclxuICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoJ3VsJykuc2xpZGVEb3duKCk7XHJcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgc2lkZWJhci51cGRhdGVTdGlja3koKTtcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICQodGhpcykucGFyZW50KCkuZmluZCgndWwnKS5zbGlkZVVwKCk7XHJcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgc2lkZWJhci51cGRhdGVTdGlja3koKTtcclxuXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG59KTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/sticky.js\n");

/***/ }),

/***/ "./lk.js":
/*!***************!*\
  !*** ./lk.js ***!
  \***************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function($) {\n\n__webpack_require__(/*! ./components/language-module */ \"./components/language-module.js\");\n\n__webpack_require__(/*! ./components/sticky */ \"./components/sticky.js\");\n\n__webpack_require__(/*! ./components/code */ \"./components/code.js\");\n\nvar _customModal = __webpack_require__(/*! ./components/custom-modal */ \"./components/custom-modal.js\");\n\nvar _notice = __webpack_require__(/*! ./components/notice */ \"./components/notice.js\");\n\n// main\n$(document).ready(function () {\n    $('.loader').fadeOut();\n});\n\n// copy to clipboard\nvar copy = document.querySelectorAll('.js-copy');\ncopy.forEach(function (element) {\n    var copyButton = element.querySelector('.js-copy-button');\n    var copyInput = element.querySelector('.js-copy-input');\n    copyButton.onclick = function (e) {\n        e.preventDefault;\n        copyInput.select();\n        copyInput.setSelectionRange(0, 9999);\n        document.execCommand('copy');\n        (0, _notice.showSuccess)('Скопировано');\n    };\n});\n\n// 2fa checker\n$('.js-2fa-checker').click(function () {\n    if ($('.js-2fa-checker').is(':checked')) {\n        (0, _customModal.openCustomModal)('2fa');\n    }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\")))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9say5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbGsuanM/OTI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vY29tcG9uZW50cy9sYW5ndWFnZS1tb2R1bGUnO1xyXG5pbXBvcnQgJy4vY29tcG9uZW50cy9zdGlja3knO1xyXG5pbXBvcnQgJy4vY29tcG9uZW50cy9jb2RlJztcclxuaW1wb3J0IHtcclxuICAgIGNsb3NlQ3VzdG9tTW9kYWwsXHJcbiAgICBvcGVuQ3VzdG9tTW9kYWxcclxufSBmcm9tICcuL2NvbXBvbmVudHMvY3VzdG9tLW1vZGFsJztcclxuaW1wb3J0IHtcclxuICAgIHNob3dTdWNjZXNzLFxyXG4gICAgc2hvd0Vycm9yXHJcbn0gZnJvbSAnLi9jb21wb25lbnRzL25vdGljZSc7XHJcblxyXG4vLyBtYWluXHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICQoJy5sb2FkZXInKS5mYWRlT3V0KCk7XHJcbn0pO1xyXG5cclxuLy8gY29weSB0byBjbGlwYm9hcmRcclxuY29uc3QgY29weSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcy1jb3B5Jyk7XHJcbmNvcHkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgY29uc3QgY29weUJ1dHRvbiA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignLmpzLWNvcHktYnV0dG9uJyk7XHJcbiAgICBjb25zdCBjb3B5SW5wdXQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1jb3B5LWlucHV0Jyk7XHJcbiAgICBjb3B5QnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQ7XHJcbiAgICAgICAgY29weUlucHV0LnNlbGVjdCgpO1xyXG4gICAgICAgIGNvcHlJbnB1dC5zZXRTZWxlY3Rpb25SYW5nZSgwLCA5OTk5KTtcclxuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xyXG4gICAgICAgIHNob3dTdWNjZXNzKCfQodC60L7Qv9C40YDQvtCy0LDQvdC+Jyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gMmZhIGNoZWNrZXJcclxuJCgnLmpzLTJmYS1jaGVja2VyJykuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCQoJy5qcy0yZmEtY2hlY2tlcicpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgb3BlbkN1c3RvbU1vZGFsKCcyZmEnKTtcclxuICAgIH1cclxufSk7Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lk.js\n");

/***/ })

/******/ });